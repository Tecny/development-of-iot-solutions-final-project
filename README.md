<br>
<br>
<br>

<p align="center">
  <img src="https://raw.githubusercontent.com//HenryCenturion//open-source-final-project//develop//informe//images//upc.png" alt="UPC">
</p>

<br>

<p align="center"><strong>UNIVERSIDAD PERUANA DE CIENCIAS APLICADAS</strong></p>

<br>

<p align="center"><strong>TRABAJO FINAL</strong></p>

<br>

<p align="center"><strong>Curso: Desarrollo de Soluciones IoT</strong></p>

<br>

<p align="center"><strong>NRC: 15260</strong></p>

<br>

<p align="center"><strong>Grupo: 1</strong></p>

<br>

<p align="center"><strong>Docente: David Vera Olivera</strong></p>

<br>

<p align="center"><strong>Integrantes:</strong></p>

<br>

<p align="center"><strong>Méndez López, Sebastián Alonso – U202211561</strong></p>

<br>

<p align="center"><strong>Centurión Quintana, Henry Manuel – U20221A339</strong></p>

<br>

<p align="center"><strong>Atencio Castillo, John Alexis - U202218229</strong></p>

<br>

<p align="center"><strong>Frisancho Levano, Sebastian Mathias Salomon - U202224392</strong></p>

<br>

<p align="center"><strong>Valentin Ricaldi, Willy David - U20201C037</strong></p>

<br>

<p align="center"><strong>Valverde Salazar, Clara Angie - U20201B940</strong></p>

<br>

<br>
<br>

<div style="text-align: center;">
<br>
<br>
<br>

## Tabla de Contenido
</div>
<br>
<br>

</div>

<div style="margin-left: 30px;">

### Student Outcome <br>

<table>
  <tr>
    <th valign="top">Criterio específico</th>
    <th valign="top">Acciones realizadas</th>
    <th valign="top">Conclusiones</th>
  </tr>
  <tr>
    <td rowspan="6" valign="top">Trabaja en equipo para proporcionar liderazgo en forma conjunta </td>
    <td valign="top">
      TB1: John Atencio: Coordiné una de las sesiones de presentación interna, organizando el contenido de manera colaborativa y distribuyendo los roles de exposición.
      <br><br>
    </td>
    <td rowspan="6" valign="middle">
      Como equipo, compartimos el liderazgo en cada etapa del proyecto, adaptándonos según las fortalezas y experiencias de cada integrante. Este enfoque permitió una mejor toma de decisiones, mayor compromiso y una distribución equitativa de responsabilidades. La rotación de roles de liderazgo fortaleció la autonomía del grupo y fomentó un sentido colectivo de propiedad sobre el proyecto. (TB1)
    </td>
  </tr>
  <tr>
    <td valign="top">
      TB1: Henry Centurion: Tomé la iniciativa en las decisiones clave del diseño estratégico del dominio, promoviendo la participación equitativa y justificando cada decisión técnica.
      <br><br>
    </td>
  </tr>
  <tr>
    <td valign="top">
      TB1: Sebastián Frisancho: Lideré la definición inicial de hipótesis en el proceso Lean UX, coordinando al equipo para alinear ideas y enfocar los esfuerzos desde el inicio.
      <br><br>
    </td>
  </tr>
  <tr>
    <td valign="top">
      TB1: Sebastián Mendez: Lideré el diseño de uno de los contextos del Tactical-Level Domain-Driven Design, promoviendo reuniones de revisión con el equipo para asegurar la integración de los módulos.
      <br><br>
    </td>
  </tr>
  <tr>
    <td valign="top">
      TB1: Willy Valentin: Dirigí la elaboración del modelo To-Be, integrando los aportes de mis compañeros para construir una propuesta coherente y consensuada.
      <br><br>
    </td>
  </tr>
  <tr>
    <td valign="top">
      TB1: Angie Valverde: Asumí el rol de facilitador durante las entrevistas con usuarios, guiando al equipo para obtener información valiosa y respetar los tiempos y turnos de participación
      <br><br>
    </td>
  </tr>
</table>
<table>
  <tr>
  </tr>
  <tr>
    <td rowspan="6" valign="top"> Crea un entorno colaborativo e inclusivo, establece metas, planifica tareas y cumple objetivos.</td>
    <td valign="top">
      TB1: John Atencio: Contribuí a establecer metas claras para la entrega, participando activamente en su cumplimiento y apoyando a mis compañeros cuando fue necesario. 
      <br><br>
    </td>
    <td rowspan="6" valign="middle">
      Fomentamos un ambiente de trabajo inclusivo, donde todas las voces fueron valoradas y consideradas en la toma de decisiones. Establecimos metas claras, planificamos tareas de forma colaborativa y cumplimos los objetivos propuestos gracias a una comunicación constante, organización compartida y compromiso conjunto. Esta forma de trabajo potenció la productividad y cohesión del equipo. (TB1)
    </td>
  </tr>
  <tr>
    <td valign="top">
      TB1: Henry Centurion: Me aseguré de incluir las ideas de todos en la definición de user stories, promoviendo un ambiente donde todos se sintieran escuchados y representados.
      <br><br>
    </td>
  </tr>
  <tr>
    <td valign="top">
      TB1: Sebastián Frisancho: Organicé sesiones de trabajo en las que rotamos tareas como la toma de notas y el análisis de entrevistas, para fomentar el equilibrio y la equidad.
      <br><br>
    </td>
  </tr>
  <tr>
    <td valign="top">
      TB1: Sebastián Mendez: Me comprometí con los tiempos del proyecto, entregando mis partes del diseño táctico a tiempo y ayudando a resolver bloqueos que surgieron durante la implementación.
      <br><br>
    </td>
  </tr>
  <tr>
    <td valign="top">
      TB1: Willy Valentin: Impulsé espacios de feedback constructivo durante el diseño de la arquitectura, valorando las ideas de todos y fomentando la mejora continua.
      <br><br>
    </td>
  </tr>
  <tr>
    <td valign="top">
      TB1: Angie Valverde: Propuse la planificación inicial del proyecto utilizando tableros colaborativos, lo que permitió una mejor organización y transparencia en el trabajo en equipo.
      <br><br>
    </td>
  </tr>
</table>

### Registro de versiones <br>

  | Versión | Fecha | Autor | Descripción de Modificación |
  |-|-|-|-|
  | 1.0 | 27-04-25 | Grupo Tecny | Completado los primeros 4 capitulos del informe. |

### Capitulos <br>
  [Capitulo I - Introduction](#i-introduccion) <br>
  - 1.1. [Startup Profile](#11-startup-profile) <br>
    - 1.1.1. [Descripcion de la Startup](#111-descripcion-de-la-startup) <br>
    - 1.1.2. [Perfiles de integrantes del grupo](#112-perfiles-de-integrantes-del-grupo)<br>
  - 1.2. [Solution Profile](#12-solution-profile)<br>
    - 1.2.1. [Antecedentes y problematica](#121-antecedentes-y-problematica)<br>
    - 1.2.2. [Lean UX process](#122-lean-ux-process)<br>
        - 1.2.2.1. [Lean UX Problem Statements](#1221-lean-ux-problem-statements)<br>
        - 1.2.2.2. [Lean UX Assumptions](#1222-lean-ux-assumptions)<br>
        - 1.2.2.3. [Lean UX Hypothesis Statements](#1223-lean-ux-hypothesis-statements)<br>
        - 1.2.2.4. [Lean UX Canvas](#1224-lean-ux-canvas)<br>
  - 1.3. [Segmentos objetivo](#13-segmentos-objetivo) <br>
  
  [Capitulo II - Requirements Elicitation & Analysis](#ii-requirements-analysis)<br>

  - 2.1. [Competidores](#21-competidores) <br>
    - 2.1.1. [Análisis competitivo](#211-analisis-competitivo) <br>
    - 2.1.2. [Estrategias y tacticas frente a competidores](#212-estrategias-y-tacticas-frente-a-competidores)<br>
  - 2.2. [Entrevistas](#22-entrevistas)<br>
    - 2.2.1. [Diseño de entrevistas](#221-diseño-de-entrevistas)<br>
    - 2.2.2. [Registro de entrevistas](#222-registro-de-entrevistas)<br>
    - 2.2.3. [Análisis de entrevistas](#223-analisis-de-entrevistas)<br>
  - 2.3. [Needfinding](#23-needfinding)<br>
    - 2.3.1. [User Personas](#231-user-personas)<br>
    - 2.3.2. [User Task Matrix](#232-user-task-matrix)<br>
    - 2.3.3. [User Journey Mapping](#233-user-journey-mapping)<br>
    - 2.3.4. [Empathy Mapping](#234-empathy-mapping)<br>
    - 2.3.5. [As-is Scenario Mapping](#235-as-is-scenario-mapping)<br>
  - 2.4. [Ubiquitous Language](#24-ubiquitous-language)<br>
  
  [Capitulo III - Requirements Specification](#iii-requirements-specification)<br>
  
  - 3.1. [To-Be Scenario Mapping](#31-to-be-scenario-mapping) <br>
  - 3.2. [User Stories](#32-user-stories)<br>
  - 3.3. [Impact Mapping](#33-impact-mapping) <br>
  - 3.4. [Product Backlog](#34-product-backlog) <br>

  [Capitulo IV - Solution Software Design](#iv-solution-software-design)<br>
  
  - 4.1. [Strategic-Level Domain-Driven Design](#41-strategic-level-domain-driven-design) <br>
    - 4.1.1. [Event Storming](#411-event-storming) <br>
      - 4.1.1.1. [Unstructured Exploration](#4111-unstructured-exploration) <br>
      - 4.1.1.2. [Timelines](#4112-timelines) <br>
      - 4.1.1.3. [Pain Points](#4113-pain-points) <br>
      - 4.1.1.4. [Pivotal Points](#4114-pivotal-points) <br>
      - 4.1.1.5. [Commands](#4115-commands) <br>
      - 4.1.1.6. [Policies](#4116-policies) <br>
      - 4.1.1.7. [Read Models](#4117-read-models) <br>
      - 4.1.1.8. [External Systems](#4118-external-systems) <br>
      - 4.1.1.9. [Aggregates](#4119-aggregates) <br>
      - 4.1.1.10. [Bounded Contexts](#41110-bounded-contexts) <br>
    - 4.1.2. [Candidate Context Discovery](#412-candidate-context-discovery)<br>
    - 4.1.3. [Domain Message Flows Modeling](#413-domain-message-flows-modeling)<br>
    - 4.1.4. [Bounded Context Canvases](#414-bounded-context-canvases)<br>
    - 4.1.5. [Context Mapping](#415-context-mapping) <br>
    - 4.1.6. [Software Architecture](#416-software-architecture) <br>
      - 4.1.6.1. [Software Architecture System Landscape Diagram](#4161-software-architecture-system-landscape-diagram)<br>
      - 4.1.6.2. [Software Architecture Context Level Diagrams](#4162-software-architecture-context-level-diagrams)<br>
      - 4.1.6.3. [Software Architecture Container Level Diagrams](#4163-software-architecture-container-level-diagrams)<br>
      - 4.1.6.4. [Software Architecture Deployment Level Diagrams](#4164-software-architecture-deployment-level-diagrams)<br>
  - 4.2. [Tactical-Level Domain-Driven Design](#42-tactical-level-domain-driven-design)<br>
    - 4.2.1. [Bounded Context: Users](#421-bounded-context-users) <br>
      - 4.2.1.1. [Domain Layer](#4211-domain-layer)<br>
        - 4.2.1.1.1. [Model](#42111-model)<br>
          - 4.2.1.1.1.1. [Aggregates](#421111-aggregates)<br>
          - 4.2.1.1.1.2. [Commands](#421112-commands)<br>
          - 4.2.1.1.1.3. [Entities](#421113-entities)<br>
          - 4.2.1.1.1.4. [Events](#421114-events)<br>
          - 4.2.1.1.1.5. [Queries](#421115-queries)<br>
          - 4.2.1.1.1.6. [Value Objects](#421116-value-objects)<br>
        - 4.2.1.1.2. [Services](#42112-services)<br>
        - 4.2.1.1.3. [Exceptions](#42113-exceptions)<br>
        - 4.2.1.1.4. [Config](#42114-config)<br>
      - 4.2.1.2. [Interface Layer](#4212-interface-layer)<br>
        - 4.2.1.2.1. [Resources](#42121-resources)<br>
        - 4.2.1.2.2. [Transform](#42122-transform)<br>
        - 4.2.1.2.3. [Controllers](#42123-controllers)<br>
      - 4.2.1.3. [Application Layer](#4213-application-layer)<br>
        - 4.2.1.3.1. [Command Services](#42131-command-services)<br>
        - 4.2.1.3.2. [Query Services](#42132-query-services)<br>
        - 4.2.1.3.3. [Event Handlers](#42133-event-handlers)<br>
      - 4.2.1.4. [Infrastructure Layer](#4214-infrastructure-layer)<br>
      - 4.2.1.5. [Bounded Context Software Architecture Component Level Diagrams](#4215-bounded-context-software-architecture-component-level-diagrams)<br>
      - 4.2.1.6. [Bounded Context Software Architecture Code Level Diagrams](#4216-bounded-context-software-architecture-code-level-diagrams)<br>
        - 4.2.1.6.1. [Bounded Context Domain Layer Class Diagrams](#42161-bounded-context-domain-layer-class-diagrams)<br>
        - 4.2.1.6.2. [Bounded Context Database Design Diagram](#42162-bounded-context-database-design-diagram)<br>
    - 4.2.2. [Bounded Context: Iam](#422-bounded-context-iam) <br>
      - 4.2.2.1. [Domain Layer](#4221-domain-layer)<br>
        - 4.2.2.1.1. [Model](#42211-model)<br>
          - 4.2.2.1.1.1. [Commands](#422111-commands)<br>
          - 4.2.2.1.1.2. [Queries](#422112-queries)<br>
        - 4.2.2.1.2. [Services](#42212-services)<br>
      - 4.2.2.2. [Interface Layer](#4222-interface-layer)<br>
        - 4.2.2.2.1. [Resources](#42221-resources)<br>
        - 4.2.2.2.2. [Transform](#42222-transform)<br>
        - 4.2.2.2.3. [Controllers](#42223-controllers)<br>
      - 4.2.2.3. [Application Layer](#4223-application-layer)<br>
        - 4.2.2.3.1. [OutBound Services](#42231-outbound-services)<br>
        - 4.2.2.3.2. [Query Services](#42232-query-services)<br>
        - 4.2.2.3.3. [Event Handlers](#42233-event-handlers)<br>
      - 4.2.2.4. [Infrastructure Layer](#4224-infrastructure-layer)<br>
        - 4.2.2.4.1. [Authorization](#42241-authorization)<br>
          - 4.2.2.4.1.1. [Configuration](#422411-configuration)<br>
          - 4.2.2.4.1.2. [Model](#422412-model)<br>
          - 4.2.2.4.1.3. [Pipelines](#422413-pipelines)<br>
          - 4.2.2.4.1.4. [Services](#422414-services)<br>
      - 4.2.2.5. [Bounded Context Software Architecture Component Level Diagrams](#4225-bounded-context-software-architecture-component-level-diagrams)<br>
      - 4.2.2.6. [Bounded Context Software Architecture Code Level Diagrams](#4226-bounded-context-software-architecture-code-level-diagrams)<br>
        - 4.2.2.6.1. [Bounded Context Domain Layer Class Diagrams](#42261-bounded-context-domain-layer-class-diagrams)<br>
    - 4.2.3. [Bounded Context: Subscriptions](#423-bounded-context-subscriptions) <br>
      - 4.2.3.1. [Domain Layer](#4231-domain-layer)<br>
        - 4.2.3.1.1. [Model](#42311-model)<br>
          - 4.2.3.1.1.1. [Aggregates](#423111-aggregates)<br>
          - 4.2.3.1.1.2. [Commands](#423112-commands)<br>
          - 4.2.3.1.1.3. [Entities](#423113-entities)<br>
          - 4.2.3.1.1.4. [Events](#423114-events)<br>
          - 4.2.3.1.1.5. [Queries](#423115-queries)<br>
          - 4.2.3.1.1.6. [Value Objects](#423116-value-objects)<br>
        - 4.2.3.1.2. [Services](#42312-services)<br>
      - 4.2.3.2. [Interface Layer](#4232-interface-layer)<br>
        - 4.2.3.2.1. [Resources](#42321-resources)<br>
        - 4.2.3.2.2. [Transform](#42322-transform)<br>
        - 4.2.3.2.3. [Controllers](#42323-controllers)<br>
      - 4.2.3.3. [Application Layer](#4233-application-layer)<br>
        - 4.2.3.3.1. [Command Services](#42331-command-services)<br>
        - 4.2.3.3.2. [Query Services](#42332-query-services)<br>
        - 4.2.3.3.3. [Event Handlers](#42333-event-handlers)<br>
      - 4.2.3.4. [Infrastructure Layer](#4234-infrastructure-layer)<br>
      - 4.2.3.5. [Bounded Context Software Architecture Component Level Diagrams](#4235-bounded-context-software-architecture-component-level-diagrams)<br>
      - 4.2.3.6. [Bounded Context Software Architecture Code Level Diagrams](#4236-bounded-context-software-architecture-code-level-diagrams)<br>
        - 4.2.3.6.1. [Bounded Context Domain Layer Class Diagrams](#42361-bounded-context-domain-layer-class-diagrams)<br>
        - 4.2.3.6.2. [Bounded Context Database Design Diagram](#42362-bounded-context-database-design-diagram)<br>
    - 4.2.4. [Bounded Context: Sport Spaces](#424-bounded-context-sport-spaces) <br>
      - 4.2.4.1. [Domain Layer](#4241-domain-layer)<br>
        - 4.2.4.1.1. [Model](#42411-model)<br>
          - 4.2.4.1.1.1. [Aggregates](#424111-aggregates)<br>
          - 4.2.4.1.1.2. [Commands](#424112-commands)<br>
          - 4.2.4.1.1.3. [Entities](#424113-entities)<br>
          - 4.2.4.1.1.4. [Events](#424114-events)<br>
          - 4.2.4.1.1.5. [Queries](#424115-queries)<br>
          - 4.2.4.1.1.6. [Value Objects](#424116-value-objects)<br>
        - 4.2.4.1.2. [Services](#42412-services)<br>
      - 4.2.4.2. [Interface Layer](#4242-interface-layer)<br>
        - 4.2.4.2.1. [Resources](#42421-resources)<br>
        - 4.2.4.2.2. [Transform](#42422-transform)<br>
        - 4.2.4.2.3. [Controllers](#42423-controllers)<br>
      - 4.2.4.3. [Application Layer](#4243-application-layer)<br>
        - 4.2.4.3.1. [Command Services](#42431-command-services)<br>
        - 4.2.4.3.2. [Query Services](#42432-query-services)<br>
        - 4.2.4.3.3. [Event Handlers](#42433-event-handlers)<br>
      - 4.2.4.4. [Infrastructure Layer](#4244-infrastructure-layer)<br>
      - 4.2.4.5. [Bounded Context Software Architecture Component Level Diagrams](#4245-bounded-context-software-architecture-component-level-diagrams)<br>
      - 4.2.4.6. [Bounded Context Software Architecture Code Level Diagrams](#4246-bounded-context-software-architecture-code-level-diagrams)<br>
        - 4.2.4.6.1. [Bounded Context Domain Layer Class Diagrams](#42461-bounded-context-domain-layer-class-diagrams)<br>
        - 4.2.4.6.2. [Bounded Context Database Design Diagram](#42462-bounded-context-database-design-diagram)<br>
    - 4.2.5. [Bounded Context: Reservations](#425-bounded-context-reservations) <br>
      - 4.2.5.1. [Domain Layer](#4251-domain-layer)<br>
        - 4.2.5.1.1. [Model](#42511-model)<br>
          - 4.2.5.1.1.1. [Aggregates](#425111-aggregates)<br>
          - 4.2.5.1.1.2. [Commands](#425112-commands)<br>
          - 4.2.5.1.1.3. [Entities](#425113-entities)<br>
          - 4.2.5.1.1.4. [Events](#425114-events)<br>
          - 4.2.5.1.1.5. [Queries](#425115-queries)<br>
          - 4.2.5.1.1.6. [Value Objects](#425116-value-objects)<br>
        - 4.2.5.1.2. [Services](#42512-services)<br>
      - 4.2.5.2. [Interface Layer](#4252-interface-layer)<br>
        - 4.2.5.2.1. [Resources](#42521-resources)<br>
        - 4.2.5.2.2. [Transform](#42522-transform)<br>
        - 4.2.5.2.3. [Controllers](#42523-controllers)<br>
      - 4.2.5.3. [Application Layer](#4253-application-layer)<br>
        - 4.2.5.3.1. [Command Services](#42531-command-services)<br>
        - 4.2.5.3.2. [Query Services](#42532-query-services)<br>
        - 4.2.5.3.3. [Event Handlers](#42533-event-handlers)<br>
      - 4.2.5.4. [Infrastructure Layer](#4254-infrastructure-layer)<br>
      - 4.2.5.5. [Bounded Context Software Architecture Component Level Diagrams](#4255-bounded-context-software-architecture-component-level-diagrams)<br>
      - 4.2.5.6. [Bounded Context Software Architecture Code Level Diagrams](#4256-bounded-context-software-architecture-code-level-diagrams)<br>
        - 4.2.5.6.1. [Bounded Context Domain Layer Class Diagrams](#42561-bounded-context-domain-layer-class-diagrams)<br>
        - 4.2.5.6.2. [Bounded Context Database Design Diagram](#42562-bounded-context-database-design-diagram)<br>
    - 4.2.6. [Bounded Context: Rooms](#426-bounded-context-rooms) <br>
      - 4.2.6.1. [Domain Layer](#4261-domain-layer)<br>
        - 4.2.6.1.1. [Model](#42611-model)<br>
          - 4.2.6.1.1.1. [Aggregates](#426111-aggregates)<br>
          - 4.2.6.1.1.2. [Commands](#426112-commands)<br>
          - 4.2.6.1.1.3. [Queries](#426113-queries)<br>
        - 4.2.6.1.2. [Services](#42612-services)<br>
      - 4.2.6.2. [Interface Layer](#4262-interface-layer)<br>
        - 4.2.6.2.1. [Resources](#42621-resources)<br>
        - 4.2.6.2.2. [Transform](#42622-transform)<br>
        - 4.2.6.2.3. [Controllers](#42623-controllers)<br>
      - 4.2.6.3. [Application Layer](#4263-application-layer)<br>
        - 4.2.6.3.1. [Command Services](#42631-command-services)<br>
        - 4.2.6.3.2. [Query Services](#42632-query-services)<br>
      - 4.2.6.4. [Infrastructure Layer](#4264-infrastructure-layer)<br>
      - 4.2.6.5. [Bounded Context Software Architecture Component Level Diagrams](#4265-bounded-context-software-architecture-component-level-diagrams)<br>
      - 4.2.6.6. [Bounded Context Software Architecture Code Level Diagrams](#4266-bounded-context-software-architecture-code-level-diagrams)<br>
        - 4.2.6.6.1. [Bounded Context Domain Layer Class Diagrams](#42661-bounded-context-domain-layer-class-diagrams)<br>
        - 4.2.6.6.2. [Bounded Context Database Design Diagram](#42662-bounded-context-database-design-diagram)<br>
    - 4.2.7. [Bounded Context: Player List](#427-bounded-context-player-list) <br>
      - 4.2.7.1. [Domain Layer](#4271-domain-layer)<br>
        - 4.2.7.1.1. [Model](#42711-model)<br>
          - 4.2.7.1.1.1. [Aggregates](#427111-aggregates)<br>
      - 4.2.7.2. [Interface Layer](#4272-interface-layer)<br>
        - 4.2.7.2.1. [Resources](#42721-resources)<br>
        - 4.2.7.2.2. [Transform](#42722-transform)<br>
        - 4.2.7.2.3. [Controllers](#42723-controllers)<br>
      - 4.2.7.3. [Infrastructure Layer](#4273-infrastructure-layer)<br>
      - 4.2.7.4. [Bounded Context Software Architecture Component Level Diagrams](#4274-bounded-context-software-architecture-component-level-diagrams)<br>
      - 4.2.7.5. [Bounded Context Software Architecture Code Level Diagrams](#4275-bounded-context-software-architecture-code-level-diagrams)<br>
        - 4.2.7.5.1. [Bounded Context Domain Layer Class Diagrams](#42751-bounded-context-domain-layer-class-diagrams)<br>
        - 4.2.7.5.2. [Bounded Context Database Design Diagram](#42752-bounded-context-database-design-diagram)<br>
    - 4.2.8. [Bounded Context: Chat Room](#428-bounded-context-chat-room)<br>
      - 4.2.8.1. [Domain Layer](#4281-domain-layer)<br>  
        - 4.2.8.1.1. [Model](#42811-model)<br>  
          - 4.2.8.1.1.1. [Aggregates](#428111-aggregates)<br>  
          - 4.2.8.1.1.2. [Entities](#428112-entities)<br>  
        - 4.2.8.1.2. [Services](#42812-services)<br>  
        - 4.2.8.1.3. [Config](#42813-config)<br>  
      - 4.2.8.2. [Interface Layer](#4282-interface-layer)<br>  
        - 4.2.8.2.1. [Controllers](#42821-controllers)<br>  
      - 4.2.8.3. [Application Layer](#4283-application-layer)<br>  
        - 4.2.8.3.1. [Command Services](#42831-command-services)<br>
      - 4.2.8.4. [Infrastructure Layer](#4284-infrastructure-layer)<br>  
      - 4.2.8.5. [Bounded Context Software Architecture Component Level Diagrams](#4285-bounded-context-software-architecture-component-level-diagrams)<br>  
      - 4.2.8.6. [Bounded Context Software Architecture Code Level Diagrams](#4286-bounded-context-software-architecture-code-level-diagrams)<br>  
        - 4.2.8.6.1. [Bounded Context Domain Layer Class Diagrams](#42861-bounded-context-domain-layer-class-diagrams)<br>  
        - 4.2.8.6.2. [Bounded Context Database Design Diagram](#42862-bounded-context-database-design-diagram)<br>
    - 4.2.9. [Bounded Context: Deposit](#429-bounded-context-deposit)<br>
      - 4.2.9.1. [Domain Layer](#4291-domain-layer)<br>  
        - 4.2.9.1.1. [Model](#42911-model)<br>  
          - 4.2.9.1.1.1. [Aggregates](#429111-aggregates)<br>  
          - 4.2.9.1.1.2. [Commands](#429112-commands)<br>  
          - 4.2.9.1.1.3. [Queries](#429113-queries)<br>  
        - 4.2.9.1.2. [Services](#42912-services)<br>  
      - 4.2.9.2. [Interface Layer](#4292-interface-layer)<br>  
        - 4.2.9.2.1. [Controllers](#42921-controllers)<br>  
      - 4.2.9.3. [Application Layer](#4293-application-layer)<br>  
        - 4.2.9.3.1. [Command Services](#42931-command-services)<br>  
        - 4.2.9.3.2. [Query Services](#42932-query-services)<br>  
      - 4.2.9.4. [Infrastructure Layer](#4294-infrastructure-layer)<br>  
      - 4.2.9.5. [Bounded Context Software Architecture Component Level Diagrams](#4295-bounded-context-software-architecture-component-level-diagrams)<br>  
      - 4.2.9.6. [Bounded Context Software Architecture Code Level Diagrams](#4296-bounded-context-software-architecture-code-level-diagrams)<br>  
        - 4.2.9.6.1. [Bounded Context Domain Layer Class Diagrams](#42961-bounded-context-domain-layer-class-diagrams)<br>  
        - 4.2.9.6.2. [Bounded Context Database Design Diagram](#42962-bounded-context-database-design-diagram)<br>  
    - 4.2.10. [Bounded Context: Bank Transfer](#4210-bounded-context-bank-transfer)<br>
      - 4.2.10.1. [Domain Layer](#42101-domain-layer)<br>  
        - 4.2.10.1.1. [Model](#421011-model)<br>  
          - 4.2.10.1.1.1. [Aggregates](#4210111-aggregates)<br>  
          - 4.2.10.1.1.2. [Commands](#4210112-commands)<br>  
          - 4.2.10.1.1.3. [Queries](#4210113-queries)<br>  
        - 4.2.10.1.2. [Services](#421012-services)<br>  
      - 4.2.10.2. [Interface Layer](#42102-interface-layer)<br>  
        - 4.2.10.2.1. [Resources](#421021-resources)<br>  
        - 4.2.10.2.2. [Transform](#421022-transform)<br>  
        - 4.2.10.2.3. [Controllers](#421023-controllers)<br>  
      - 4.2.10.3. [Application Layer](#42103-application-layer)<br>  
        - 4.2.10.3.1. [Command Services](#421031-command-services)<br>  
      - 4.2.10.4. [Infrastructure Layer](#42104-infrastructure-layer)<br>  
      - 4.2.10.5. [Bounded Context Software Architecture Component Level Diagrams](#42105-bounded-context-software-architecture-component-level-diagrams)<br>  
      - 4.2.10.6. [Bounded Context Software Architecture Code Level Diagrams](#42106-bounded-context-software-architecture-code-level-diagrams)<br>  
        - 4.2.10.6.1. [Bounded Context Domain Layer Class Diagrams](#421061-bounded-context-domain-layer-class-diagrams)<br>  
        - 4.2.10.6.2. [Bounded Context Database Design Diagram](#421062-bounded-context-database-design-diagram)<br>
    - 4.2.11. [Bounded Context: Payments](#4211-bounded-context-payments)<br>
      - 4.2.11.1. [Domain Layer](#42111-domain-layer)<br>  
        - 4.2.11.1.1. [Model](#421111-model)<br>  
          - 4.2.11.1.1.1. [Aggregates](#4211111-aggregates)<br>  
          - 4.2.11.1.1.2. [Queries](#4211112-queries)<br>   
        - 4.2.11.1.2. [Services](#421112-services)<br>   
      - 4.2.11.2. [Application Layer](#42112-application-layer)<br>  
        - 4.2.11.2.1. [Command Services](#421121-command-services)<br>  
        - 4.2.11.2.2. [Query Services](#421122-query-services)<br>  
      - 4.2.11.3. [Infrastructure Layer](#42113-infrastructure-layer)<br>  
      - 4.2.11.4. [Bounded Context Software Architecture Component Level Diagrams](#42114-bounded-context-software-architecture-component-level-diagrams)<br>  
      - 4.2.11.5. [Bounded Context Software Architecture Code Level Diagrams](#42115-bounded-context-software-architecture-code-level-diagrams)<br>  
        - 4.2.11.5.1. [Bounded Context Domain Layer Class Diagrams](#421151-bounded-context-domain-layer-class-diagrams)<br>  
        - 4.2.11.5.2. [Bounded Context Database Design Diagram](#421152-bounded-context-database-design-diagram)<br>
  
  [Conclusiones](#conclusiones)<br>
  [Bibliografía](#bibliografia)<br>
  [Anexos](#anexos)<br>

</div>
<br>

# I. Introduccion

## 1.1. Startup Profile

### 1.1.1. Descripcion de la Startup

<div style="text-align: justify;">

Tecny es una innovadora startup creada por estudiantes de la UPC de la carrera de Ingenieria de Software. Está dedicada a impulsar la transformación digital a través de soluciones tecnológicas creativas y eficientes. Desde desarrollo de software a medida hasta consultoría tecnológica. Nuestro enfoque se centra en satisfacer las necesidades de nuestros clientes con soluciones personalizadas y de vanguardia. En Tecny, estamos comprometidos con la excelencia tecnológica y la creación de un futuro digital más accesible y dinámico para todos.

</div>

### 1.1.2. Perfiles de integrantes del grupo

**Henry Centurion**

| Foto                                     | Descripción              |
|--------------------------------------------|--------------------------|
| <img src="https://raw.githubusercontent.com/HenryCenturion/open-source-final-project//develop//informe//images//henry1.png" alt="UPC"> | Mi nombre es Henry Centurión, tengo 22 años y soy estudiante de la carrera de Ingeniería de Software de la Universidad Peruana de Ciencias Aplicadas (UPC). Soy alguien feliz, tranquilo y a quien le gusta trabajar en equipo para llegar a las metas acordadas. Siempre he estado interesado en la tecnología y cómo es que funcionan desde su código base. Además de ello, mis pasatiempos son hacer deporte en general y programar en C++, el cual es mi principal lenguaje de programación. Mi meta es convertirme en un gran profesional y aportar mi conocimiento a la sociedad.|
<br>

**John Atencio**
| Foto                                     | Descripción              |
|--------------------------------------------|--------------------------|
| <img src="https://raw.githubusercontent.com/HenryCenturion/open-source-final-project//develop//informe//images//john2.jpg" alt="UPC"> | Mi nombre es John Atencio, actualmente tengo 22 años y estoy estudiando la carrera de Ingeniería de software en la Universidad Peruana de Ciencias Aplicadas (UPC). Dentro de mis aspectos personales, siempre me he considerado alguien bastante relajado y sobre todo curioso. Por ello, desde niño he tenido la curiosidad de conocer los procesos y funciones detrás de las computadoras para que estas operen como un minicerebro. Esto último, fue fundamental para la elección de mi carrera.|

<br>

**Sebastian Frisancho**
| Foto                                     | Descripción              |
|--------------------------------------------|--------------------------|
| <img src="https://raw.githubusercontent.com/HenryCenturion/open-source-final-project//develop//informe//images//free1.jpg" alt="UPC"> | Mi nombre es Sebastian Frisancho, tengo 22 años y soy estudiante de Ingeniería de Software en la Universidad Peruana de Ciencias Aplicadas. Me gustan los deportes como ir al gimnasio, practicar fútbol, básquet e incluso natación. Desde pequeño me encontré rodeado de tecnología por lo que me gustaría poder tener softwares propios que me generen ingresos sin tener que trabajar en una ciudad fija. Me gustaría estudiar de manera autodidacta HTML, CSS y SQL para poder tener más conocimientos que me sirvan en mi futuro.|

<br>

**Sebastian Mendez**
| Foto                                     | Descripción              |
|--------------------------------------------|--------------------------|
| <img src="https://raw.githubusercontent.com/HenryCenturion/open-source-final-project//develop//informe//images//sebas.png" alt="UPC"> | Mi nombre es Sebastian Mendez, tengo 20 años y actualmente estoy cursando el séptimo ciclo de la carrera de Ingeniería de Software en la Universidad Peruana de Ciencias Aplicadas (UPC). Puedo decir que soy una persona muy perseverante, con metas claras y con objetivos propuestos a futuro. Además, soy una persona que considera que tiene mucha curiosidad con respecto al tema de la tecnología y sobre qué hay detrás de todo el tema de la programación. Mis pasatiempos son, jugar al básquet, los videojuegos, ir al gimnasio y programar ocasionalmente.|

<br>

**Willy Valentin**
| Foto                                     | Descripción              |
|--------------------------------------------|--------------------------|
| <img width="459px" height="170px" src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//willy.png" alt="UPC"> | Soy Willy David Valentin Ricaldi, estudio la carrera de Ingeniería de Software. Actualmente, me encuentro trabajando en una empresa minera en el área de TI. Tengo experiencia en desarrollo, gestión y mantenimiento de Software utilizando metodologías ágiles y tecnologías modernas. Lidero la rama estudiantil ACM - UPC desde hace más de un año y esto representa el nivel de liderazgo que tengo en proyectos medianos y grandes. |


**Angie Valverde**
| Foto                                     | Descripción              |
|--------------------------------------------|--------------------------|
| <img width="906px" height="170px" src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//clara.png" alt="UPC"> | Mi nombre es Clara Valverde y actualmente formo parte del equipo Atlassian en la empresa Software Enterprise Services, donde brindamos soluciones especializadas en SAP. Me encuentro cursando el noveno ciclo de la carrera de Ingeniería de Software, y tengo un fuerte interés en la eficiencia y la mejora continua dentro del desarrollo de proyectos. Me considero una persona organizada, comprometida con mis objetivos y en constante búsqueda de crecimiento tanto profesional como personal. Tengo una gran afinidad por el mundo tecnológico, especialmente en lo relacionado con la gestión de proyectos y el uso de herramientas colaborativas que optimicen los procesos. En mi tiempo libre, disfruto entrenar en el gimnasio, ya que es parte de mis metas personales de bienestar, y también dedico atención al cuidado de la piel, un tema que me interesa mucho a nivel personal. |


<br>

## 1.2. Solution Profile

D’Taquito es una plataforma innovadora diseñada para revolucionar la forma en que se organizan y disfrutan las actividades deportivas en Lima Metropolitana, conectando a personas con intereses comunes en fútbol, billar y más. Vamos más allá de la simple reserva, ofreciendo una experiencia comunitaria enriquecedora y, gracias a una solución IoT de vanguardia, garantizando la seguridad y eficiencia en el acceso a los espacios deportivos.

Nuestra plataforma facilita la creación de comunidades vibrantes y la interacción entre usuarios, permitiendo la organización eficiente de eventos deportivos a través de dos modalidades de reserva:

- Reservas Personales: Asegura directamente un horario para tu uso privado del espacio deportivo de manera rápida y sencilla.
- Reservas Comunitarias: Crea automáticamente una sala abierta donde otros jugadores interesados pueden unirse a tu evento, fomentando la colaboración y nuevas conexiones dentro de la comunidad deportiva.

La experiencia comunitaria se enriquece con salas dedicadas donde los usuarios pueden chatear, compartir información crucial del evento y gestionar la asistencia sin complicaciones.

Para los propietarios de espacios deportivos, D'Taquito se convierte en una poderosa herramienta de promoción y administración. Sus instalaciones se presentan con información detallada, permitiendo a los usuarios explorar, filtrar y reservar en tiempo real según sus preferencias. Además integra una solución IoT de seguridad que optimiza el acceso a los espacios deportivos. Cada reserva genera un código QR único. Al llegar al espacio deportivo, los usuarios simplemente escanean este código a través de un lector QR instalado, activando automáticamente su reserva y permitiendo el acceso seguro. Este sistema no solo agiliza el proceso de entrada, sino que también proporciona un registro digital de los accesos, mejorando la seguridad y el control del espacio deportivo.

Con su interfaz intuitiva y la incorporación de esta innovadora solución IoT, D'Taquito simplifica la organización de actividades deportivas, elimina las tediosas coordinaciones externas, ahorra tiempo valioso y, lo más importante, ofrece una experiencia segura y fluida para todos los usuarios, permitiéndoles enfocarse en la pasión por el deporte y la comunidad que lo comparte.

### 1.2.1. Antecedentes y problematica

**Antecedentes:**

El amor por el fútbol es una pasión arraigada en la cultura peruana, especialmente en Lima Metropolitana, donde miles de aficionados disfrutan regularmente del deporte rey en diversas canchas de la ciudad. Sin embargo, a pesar de la popularidad del fútbol, reservar canchas para jugar suele ser un proceso complicado y poco eficiente. Los jugadores enfrentan dificultades para encontrar canchas disponibles, comunicarse con los administradores de las instalaciones y asegurar horarios convenientes para sus partidos.
Además del fútbol, el billar está ganando popularidad entre los limeños, con numerosos locales ofreciendo partidas emocionantes entre amigos o en torneos locales. Aunque menos famoso que el fútbol, el billar destaca por su accesibilidad y versatilidad, solo requiriendo una mesa y tacos. Sin embargo, el aumento en la demanda ha hecho que reservar mesas de billar sea igual de complicado que reservar canchas de fútbol en Lima Metropolitana.

**Problemática:**

- **What (Qué):** El problema radica en la dificultad para encontrar y reservar canchas de fútbol y mesas de billar de manera rápida y segura en Lima Metropolitana. Esta problemática afecta directamente a los aficionados al fútbol y billar que desean organizar partidos con amigos, equipos amateurs y torneos recreativos en la ciudad. La relación con la persona en cuestión es que experimentan frustración y pérdida de tiempo al tratar de asegurar un lugar donde jugar.

- **When (Cuándo):** El problema surge cada vez que los usuarios desean programar un partido de fútbol u obtener una mesa de billar, ya sea de manera regular o esporádica. Los clientes experimentan este problema en el momento en que intentan organizar un partido, lo que puede ocurrir en cualquier momento en que deseen jugar al fútbol o billar.

- **Where (Dónde):** Los clientes están generalmente en sus hogares o lugares de trabajo. El problema surge en la dificultad de encontrar canchas o salones disponibles en ubicaciones convenientes para los usuarios, lo que a menudo requiere desplazamientos innecesarios o tiempo perdido. El problema también puede surgir cuando los usuarios se encuentran en las canchas o salones y descubren que no están disponibles debido a reservas conflictivas o falta de información actualizada.

- **Who (Quién):** Los principales involucrados son los aficionados al fútbol y al biillar que desean organizar partidos. Esta problemática afecta directamente a estos usuarios, quienes experimentan dificultades para encontrar y reservar canchas de fútbol o salones de billar.

- **Why (Por qué):** La causa del problema radica en la falta de una plataforma centralizada y eficiente para buscar, reservar y pagar por el uso de canchas y mesas. La ausencia de un sistema unificado dificulta la organización de partidos y limita la experiencia de juego.

- **How (Cómo):** El problema se presenta a través de las reservas de canchas de fútbol y mesas de billar en Lima Metropolitana.

- **How much (Cuánto):** Según Muro (2020), se presentan las siguientes estadísticas en la problemática:

  - Cerca del 71.8% de los participantes en la encuesta se involucran en el fútbol al menos una vez cada semana. Esto sugiere que existe una potencial demanda considerable para nuestro servicio.

  - En lo que respecta a los lugares donde suelen practicar fútbol, el 38.6% de los encuestados optan por centros deportivos con césped artificial, mientras que el 27.2% prefieren polideportivos. Esto implica que el 65.8% de las personas encuestadas requieren realizar una reserva para poder jugar fútbol.

  - Se indagó específicamente a quienes juegan fútbol en instalaciones deportivas con césped sintético para determinar la modalidad más común de reserva, y se descubrió que el 89.7% de ellos realiza sus reservas de canchas sintéticas llamando por teléfono a los centros deportivos.

  - Uno de los problemas principales que enfrenta nuestra muestra al intentar jugar fútbol es la falta de disponibilidad de canchas sintéticas, así como la ausencia de sus amigos para participar.

  - El 89.6% de los encuestados afirmaron que estarían dispuestos a utilizar una plataforma digital para agilizar la reserva de canchas sintéticas. Esto confirma la presencia de una demanda sin satisfacer en el mercado.


### 1.2.2. Lean UX process

#### 1.2.2.1. Lean UX Problem Statements

**Problem Statement 1** <br>
Nuestra startup enfrenta el desafío de desarrollar una plataforma digital que simplifique la reserva de espacios deportivos y a la vez fomente la formación de comunidades activas en Lima Metropolitana. La plataforma debe permitir a los usuarios realizar reservas personales o crear reservas comunitarias, estas últimas generando automáticamente salas abiertas para que otros jugadores se unan. Este sistema debe facilitar la conexión entre personas con intereses comunes, la elección eficiente de espacios deportivos disponibles, y una coordinación fluida para la realización de partidos de fútbol o sesiones de billar.
¿Cómo podemos diseñar una plataforma que combine reservas flexibles con herramientas de comunidad, para que los usuarios no solo organicen actividades fácilmente, sino también fortalezcan vínculos sociales a través del deporte?


**Problem Statement 2** <br>
A medida que los usuarios interactúan en un entorno que mezcla lo social con la organización de eventos presenciales, surge el reto de garantizar un espacio seguro, confiable y transparente. Es crucial proteger tanto a jugadores como a propietarios de espacios deportivos, generando confianza en cada paso del proceso: desde la creación de una reserva, hasta la participación en una sala comunitaria o el uso de las instalaciones.
¿Cómo podemos asegurar que la plataforma ofrezca una experiencia segura y confiable para todos los usuarios, promoviendo interacciones genuinas, coordinación efectiva y un entorno donde se valore el respeto y la integridad dentro de las actividades deportivas?


#### 1.2.2.2. Lean UX Assumptions

**Business Outcomes**

1.	Reducir el tiempo de organización de actividades deportivas desde la reserva hasta la coordinación.
2.	Aumentar la participación en reservas comunitarias y salas asociadas.
3.	Mejorar la satisfacción del usuario, medida por encuestas de feedback.
4.	Incrementar usuarios registrados y activos, fomentando comunidad.
5.	Aumentar reservas mediante mejor visibilidad de espacios deportivos.
6.	Elevar la retención de usuarios con una experiencia fluida y conectada.
7.	Disminuir cancelaciones gracias a salas y comunicación eficiente.
8.	Incrementar el uso de instalaciones deportivas afiliadas.
9.	Expandir la base de usuarios con marketing enfocado en comunidad y deporte.
10.	Conseguir alianzas con espacios deportivos y organizaciones locales.
11.	Mejorar la confianza del usuario con medidas de seguridad y protección de datos.

**User Outcomes**
1.	Los usuarios organizan actividades deportivas más rápido, gracias a un sistema de reservas ágil y opciones de comunidad sin necesidad de coordinaciones externas.
2.	Los usuarios amplían su red social, al unirse a salas comunitarias con personas que comparten intereses deportivos.
3.	Los usuarios se sienten parte de una comunidad activa, lo que mejora su experiencia y compromiso con la plataforma.
4.	Los propietarios obtienen mayor visibilidad, ya que sus espacios se promocionan dentro de reservas y salas creadas por los usuarios.
5.	Los usuarios encuentran y reservan espacios fácilmente, coordinando sus actividades sin complicaciones.
6.	Los propietarios mejoran la eficiencia y uso de sus espacios, gracias a una mayor exposición y mejor gestión desde la plataforma.

#### 1.2.2.3. Lean UX Hypothesis Statements

1.	Creemos que reducir los tiempos de organización se logrará si los usuarios pueden crear reservas (personales o comunitarias) de forma rápida mediante una interfaz intuitiva. Lo sabremos cuando disminuya el tiempo promedio que tardan en organizar actividades.
2.	Creemos que aumentará la participación en reservas comunitarias si los usuarios pueden conectarse fácilmente con otros y organizar eventos compartidos desde la reserva. Lo sabremos cuando suba el número de usuarios que crean o se unen a estas salas.
3.	Creemos que la satisfacción del usuario crecerá si la experiencia de organización y comunidad es fluida y conectada. Lo sabremos cuando aumente el índice de satisfacción en encuestas y comentarios positivos.
4.	Creemos que mejorar la visibilidad y reservas de espacios deportivos se logrará si estos pueden promocionarse dentro del flujo de reservas comunitarias. Lo sabremos cuando veamos más reservas asociadas a espacios destacados y mayor tráfico en sus perfiles.
5.	Creemos que la retención de usuarios mejorará si ofrecemos flexibilidad en la organización y una experiencia consistente. Lo sabremos cuando aumente la tasa de usuarios recurrentes.
6.	Creemos que la utilización de espacios deportivos crecerá si facilitamos la conexión entre usuarios y espacios mediante reservas comunitarias bien estructuradas. Lo sabremos cuando aumente el uso constante de instalaciones por usuarios activos.


#### 1.2.2.4. Lean UX Canvas
<div style="text-align: justify;">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//ux-canvas.png" alt="UPC">
</div>

### 1.3. Segmentos objetivo

**Segmento objetivo 1: Personas que juegan futbol**
  - Aspectos demográficos:
    - Sexo: Hombres y mujeres.
    - Edades: De 15 a 45 años.
    - Nivel Socioeconómico: Medio y medio-alto.

  - Aspectos geográficos:
    - Nacionalidad: Residentes en Lima, Perú.
    - Zona Geográfica: Área Metropolitana de Lima
    - Departamento: Lima Metropolitana.

  - Aspectos psicográficos:
    - Intereses: Aficionados al fútbol, tanto jugadores como espectadores.
    - Estilo de Vida: Activo y deportivo.

**Segmento objetivo 2: Personas que juegan billar**  
  - Aspectos demográficos:
    -	Sexo: Hombres y mujeres.
    - Edades: De 15 a 45 años.
    - Nivel Socioeconómico: Medio y medio-alto.

  - Aspectos geográficos:
    - Nacionalidad: Residentes en Lima, Perú.
    - Zona Geográfica: Área Metropolitana de Lima.
    - Departamento: Lima Metropolitana.

  - Aspectos psicográficos:
    - Intereses: Aficionados al billar, tanto jugadores como espectadores.
    - Estilo de Vida: Activo y deportivo.

**Segmento objetivo 3: Personas dueñas de un espacio de juego**
  - Aspectos demográficos:
    -	Sexo: Hombres y mujeres.
    - Edades: De 25 a 60 años.
    - Nivel Socioeconómico: Medio-alto y Alto.

  - Aspectos geográficos:
    - Nacionalidad: Residentes en Lima, Perú.
    - Zona Geográfica: Área Metropolitana de Lima.
    - Departamento: Lima Metropolitana.

  - Aspectos psicográficos:
    - Intereses: Administradores de espacios de juego.
    - Estilo de Vida: Activo para hacer negocios.

# II. Requirements Analysis

## 2.1. Competidores

### 2.1.1. Analisis competitivo

| Competidores             | D'Taquito              | MiCancha              | ¿Donde juego?              | AlquilaTuCancha          |
|-------------------------------------|-------------------------------------|-------------------------------------|-------------------------------------|-------------------------------------|
| Logos | <img src="https://raw.githubusercontent.com//HenryCenturion//open-source-final-project//develop//informe//images//logo.jpg" alt="UPC">    | <img src="https://raw.githubusercontent.com//HenryCenturion//open-source-final-project//develop//informe//images//logo2.jpg" alt="UPC">    | <img src="https://raw.githubusercontent.com//HenryCenturion//open-source-final-project//develop//informe//images//logo3.png" alt="UPC">    | <img src="https://raw.githubusercontent.com//HenryCenturion//open-source-final-project//develop//informe//images//logo4.png" alt="UPC">    |
| Overview | D'Taquito es una aplicación web diseñada para facilitar la reserva de canchas de fútbol y mesas de billar en la región de Lima Metropolitana. Permite a los usuarios encontrar y reservar desde su navegador web, ofreciendo una amplia selección de opciones en diferentes ubicaciones. La aplicación proporciona información detallada sobre cada cancha y mesa, incluyendo fotos e instalaciones, y garantiza transacciones seguras | MiCancha es una aplicación que facilita la reserva de canchas deportivas. Con MiCancha, puedes hacer tu reserva en cualquier momento y en cualquier lugar. Esta plataforma digital elimina la necesidad de llamar para reservar tu cancha, ofreciendo una forma más fácil y rápida de reservar. | ¿Donde juego?, es una aplicacion que facilita al usuario a poder reservar espacios deportivos de manera efectiva y rapida, quitando toda la parte tediosa de recurrir al local antes del evento, esto facilita que la reserva se realize de manera remota.| AlquilaTuCancha ofrece una plataforma de gestión para centros deportivos en América Latina, con el propósito de digitalizar y optimizar los procesos burocráticos relacionados con la renta de estos establecimientos. Permite a los usuarios explorar y reservar canchas disponibles en tiempo real en su ciudad. Además, genera ingresos mediante el cobro de una tarifa mensual.|
| Ventaja competitiva | D'Taquito ofrece una ventaja competitiva al simplificar la reserva de canchas deportivas y mesas de billar. D'Taquito destaca por su plataforma integral y conveniente, permitiendo a los usuarios encontrar y reservar canchas y mesas con facilidad y seguridad desde cualquier lugar con conexión a internet. |Mientras tanto, MiCancha ofrece una solución rápida y sencilla al eliminar la necesidad de llamar para reservar, lo que ahorra tiempo y esfuerzo a los usuarios.| ¿Dónde Juego? te ofrece un sistema innovador para estar más actualizado que nunca. A través de nuestra plataforma, puedes navegar por las canchas, ver sus galería de imágenes, turnos disponibles y reservar rápidamente, sin pérdidas de tiempo.| La plataforma permite a los usuarios verificar y reservar canchas en tiempo real, con un proceso automatizado que asegura respuestas inmediatas las 24 horas del día. Esto no solo beneficia a los usuarios, sino que también incrementa los ingresos de los clubes al maximizar la ocupación de sus instalaciones.|
| Mercado objetivo | El mercado objetivo son personas que juegan futbol y billar. Se compone principalmente de hombres con edades comprendidas entre los 15 y 45 años, pertenecientes a niveles socioeconómicos medios y medio-altos. Residen en Lima, Perú, específicamente en el área metropolitana de la ciudad. Estos individuos tienen un fuerte interés en el fútbol y en el billar, tanto como jugadores activos como espectadores entusiastas del deporte. | Esta aplicación está dirigida a personas que buscan una forma fácil y rápida de reservar canchas deportivas. Su mercado objetivo puede incluir a deportistas aficionados, equipos deportivos y organizadores de eventos deportivos que necesitan una forma conveniente de reservar canchas. La aplicación puede ser especialmente útil para personas que viven en áreas urbanas donde la demanda de canchas deportivas puede ser alta. | Al igual que MiCancha, Se dirige a individuos y grupos que buscan una forma fácil de encontrar y reservar canchas deportivas. Esto podría incluir a jugadores individuales, equipos deportivos, entrenadores y organizadores de eventos deportivos.| Alquila tu Cancha brinda una solución integral para dos grupos clave: en primer lugar, ayuda a los propietarios de instalaciones deportivas a simplificar y modernizar sus operaciones, eliminando la burocracia asociada con la gestión de alquileres. Por otro lado, ofrece a los deportistas aficionados la comodidad de encontrar y reservar fácilmente canchas para una variedad de deportes, desde fútbol y pádel hasta tenis y básquetbol, de manera rápida y conveniente.|
| Estrategias de marketing |La estrategia de marketing se enfoca en redes sociales, influencers, programas de referidos y SEO para impulsar la aplicación. Utiliza contenido relevante y anuncios dirigidos en plataformas como Facebook, Instagram y Twitter, colabora con influencers locales para aumentar la visibilidad, implementa programas de referidos para fomentar el crecimiento orgánico y se centra en la optimización para motores de búsqueda para mejorar la visibilidad en línea.| Suele utilizar estrategias como el marketing en redes sociales, el marketing de contenidos, la optimización para motores de búsqueda (SEO), y las asociaciones con influencers o micro-influencers. | Esta aplicación Muestra que su estrategia de marketing podría incluir la promoción de su facilidad de uso, la disponibilidad 24/7, y la capacidad de gestionar todo desde un dispositivo móvil. También parece que se enfocan en proporcionar una variedad de funcionalidades útiles para los propietarios de complejos deportivos, como la gestión de cajas, el registro de operaciones, y la promoción del complejo.| La estrategia de marketing se enfoca en digitalizar y optimizar los procesos de alquiler de establecimientos deportivos, con presencia en varios países de América Latina. Ofrecen características útiles para propietarios, como gestión de agendas, disponibilidad en tiempo real y estadísticas para decisiones informadas.|
| Productos & Servicios | D'Taquito es una plataforma en línea que simplifica la reserva de canchas de fútbol y mesas de billar en Lima Metropolitana. Permite a los usuarios explorar una amplia selección de canchas y mesas, el cual ofrece detalles completos sobre instalaciones y precios, facilita reservas rápidas y seguras, envía notificaciones y recordatorios, y brinda herramientas para gestionar reservas de manera sencilla.| MiCancha es una aplicación dedicada a facilitar la reserva de canchas deportivas. Sus servicios van más allá de simplemente permitir a los usuarios reservar un turno; ofrecen una experiencia integral al permitir a los usuarios comparar precios, turnos y servicios de diferentes canchas deportivas. La plataforma proporciona una interfaz intuitiva que facilita el proceso de reserva, permitiendo a los usuarios realizar reservas de forma instantánea con solo unos pocos clics. Además de la conveniencia en la reserva, MiCancha se destaca por su disponibilidad tanto en la Play Store como en la App Store, lo que garantiza que esté accesible para una amplia gama de usuarios, independientemente del dispositivo que utilicen.| Aunque la página web de ¿Donde juego? resalta su facilidad de uso y disponibilidad 24/7, y la capacidad de gestionar todo desde un dispositivo móvil, no ofrece detalles específicos sobre sus productos y servicios. Sin embargo, basándonos en la naturaleza de otras aplicaciones de reserva de canchas deportivas, es probable que ¿Donde juego? ofrezca características similares, como la búsqueda y reserva de canchas deportivas, comparación de precios, y la organización de partidos y eventos deportivos. Su enfoque en la facilidad de uso y la disponibilidad constante sugiere que buscan brindar una experiencia sin complicaciones para los usuarios, permitiéndoles acceder y reservar canchas deportivas en cualquier momento y desde cualquier lugar a través de sus dispositivos móviles. | Alquila tu Cancha ofrece una amplia gama de productos y servicios diseñados para la gestión integral de instalaciones deportivas. Esto incluye la posibilidad de realizar reservas en tiempo real, administrar completamente un club y su bar desde cualquier dispositivo, la automatización de reservas que permite una respuesta inmediata las 24 horas del día, el aumento de ingresos para los clubes al aprovechar todas las horas libres disponibles, y una experiencia amigable para los clientes al eliminar la necesidad de depender exclusivamente de los teléfonos para tomar reservas, proporcionando así una experiencia más cómoda para los usuarios.|
| Precios & Costos| D'Taquito ofrece tres tarifas diferentes en su aplicación: 9.90 para personas naturales, que sería el costo para usuarios individuales que deseen reservar canchas de fútbol y/o mesas de billar; y 99.90 para canchas o establecimiento de entretenimiento para las mesas de billar, que probablemente sea el precio que las canchas de fútbol o establecimiento de mesas de billar tendrían que pagar para utilizar los servicios de D'Taquito como plataforma de reserva.| Si bien esta aplicacion de por si es gratuita, los costos para reservar una cancha varian de acuerdo a lo requerido por el propietario del local, por lo que no es posible determinar un precio fijo | Si bien esta aplicacion de por si es gratuita, los costos para reservar una cancha varian de acuerdo a lo requerido por el propietario del local, por lo que no es posible determinar un precio fijo | Esta plataforma ofrece varios planes de acuerdo a la cantidad de canchas: el Plan Base por $10,000 mensuales o $80,400 anuales (para 1, 2 o 3 canchas), el Plan Estándar por $18,000 mensuales o $144,720 anuales (para 4, 5 o 6 canchas), y el Plan Full por $25,000 mensuales o $201,000 anuales (para 7 o más canchas).|
| Canales de distribución              | D'Taquito está disponible como un servicio web accesible a través de navegadores de internet en computadoras de escritorio, laptops y dispositivos móviles con conexión a internet. Los usuarios pueden acceder al sitio web de D'Taquito desde cualquier navegador web compatible para buscar y reservar canchas de fútbol y mesas de billar.| Esta aplicación está disponible en la web y también se puede descargar en dispositivos móviles a través de la Play Store y la App Store. Por lo tanto, sus canales de distribución son tanto web como móvil.              | La página web de ¿Donde juego? muestra que su servicio principal es la facilidad de uso, la disponibilidad 24/7, y la capacidad de gestionar todo desde un dispositivo móvil. Por lo tanto, sus canales de distribución son tanto web como móvil.             | Esta plataforma ofrece una serie de productos y servicios a través de su sitio web. Además, parece que también tienen una aplicación móvil, lo que significa que sus canales de distribución son tanto web como móvil.              |
| Fortalezas             | D'Taquito ofrece una plataforma fácil de usar tanto en su versión web como móvil, lo que facilita a los usuarios encontrar y reservar canchas de fútbol y/o mesas de billar sin complicaciones.| MiCancha ha logrado establecerse como un líder reconocido en el mercado de gestión de canchas deportivas. | Se enfoca exclusivamente en la reserva de canchas deportivas, lo que le permite ofrecer un servicio altamente especializado y centrado en las necesidades del usuario. | Puede ofrecer flexibilidad en términos de opciones de reserva, como la duración del alquiler o la disponibilidad de diferentes tipos de canchas. |
| Oportunidades             | Existe una demanda considerable en el mercado peruano para un servicio como D'Taquito, como lo indican las estadísticas presentadas en el análisis.| Puede diversificar su oferta agregando funciones adicionales, como la organización de torneos o la conexión con entrenadores y equipos. | Formar asociaciones con ligas deportivas locales o equipos populares podría ampliar su base de usuarios y aumentar la visibilidad de la marca. |Ofrecer opciones de personalización para diferentes tipos de usuarios, como equipos deportivos o aficionados individuales, podría mejorar su atractivo. | 
| Debilidades             | D'Taquito requiere una conexión a internet para funcionar correctamente, lo que puede limitar su uso en áreas con acceso limitado a internet.| Con el aumento de la competencia en el mercado de aplicaciones deportivas, MiCancha debe esforzarse por mantener su posición líder. | La aplicación depende en gran medida de una conexión a internet sólida, lo que puede representar un desafío en áreas con acceso limitado a la red. | Puede enfrentar desafíos para establecerse como una marca reconocida en un mercado competitivo. |
| Amenazas             | Los avances tecnológicos podrían dar lugar a nuevas plataformas o servicios que compitan con D'Taquito, lo que podría afectar su posición en el mercado. |Con el aumento de las amenazas cibernéticas, existe el riesgo de que la seguridad de los datos de los usuarios sea comprometida, lo que podría dañar la reputación de la marca.| La competencia con aplicaciones más establecidas y con mayores recursos podría dificultar su crecimiento y supervivencia.| El rápido avance tecnológico podría requerir inversiones adicionales para mantenerse al día con las expectativas de los usuarios y las tendencias del mercado.|

### 2.1.2. Estrategias y tacticas frente a competidores

<div style="text-align: justify;">

Bajo el concepto de estrategia competitiva se encuentra el plan de una empresa que se diseña para maximizar las fortalezas, desarrollar nuevas capacidades y aprovechar oportunidades respecto a sus competidores. Esta estrategia siempre está pensada para el largo plazo.
Una estrategia competitiva se compone de una serie de características que hacen que una compañía se desmarque respecto a su competencia, consiguiendo una posición de ventaja en el mercado y obteniendo así una mayor rentabilidad.

Estrategias:

- *Diferenciacion del producto:* Destacar nuestras características únicas de nuestro servicio nos servirá para sobresalir frente a la competencia.
- *Segmentacion del mercado:* Definir correctamente nuestro público objetivo nos permitirá conocer sus ideales y caracaterísticas.
- *Experiencia de usuario (UX) y diseño:* Asegurar que el servicio sea facil de utilizar y visualmente atractiva.
- *Gamificacion*: Diseñar e implementar un servicio de subscripción para brindar mejoras a los usuarios afiliados.

</div>

## 2.2. Entrevistas

### 2.2.1. Diseño de entrevistas

<div style="text-align: justify;">

**Para todos los segmentos:**

- ¿Cuál es tu nombre completo?
- ¿Qué edad tienes?
- ¿Cuál es tu género?
- ¿De qué distrito de Lima Metropolitana eres?
- ¿Tienes profesión o estudias?
- ¿Cómo suele ser tu día a día?
- ¿Juegas fútbol o billar? (solo si es jugador)
- ¿Eres administrador de algún espacio deportivo? Si es así, ¿de cuáles deportes? (solo si es propietario)

**Para segmento 1:**

- ¿Con qué frecuencia juegas fútbol o billar?
- ¿Tienes amigos con quienes sueles jugar con frecuencia o a veces te cuesta coincidir por temas de disponibilidad u horarios?
- ¿Cómo sueles organizar tus partidas actualmente? ¿Utilizas alguna red social para organizarlas? Si es así, ¿cuál y por qué?
- ¿Qué dificultades enfrentas al intentar organizar un partido de fútbol o billar?
- ¿Con qué frecuencia reservas canchas o mesas de billar?
- ¿Qué aspectos valoras más al momento de reservar un espacio deportivo (precio, disponibilidad, ubicación, calidad del espacio, etc.)?
- ¿Qué método usas actualmente para hacer reservas (presencial, llamada, mensaje, app, etc.)? ¿Qué tan cómodo o incómodo te parece ese método?
- ¿Te gustaría poder ver la disponibilidad de espacios en tiempo real antes de reservar?
- ¿Te interesaría participar en partidas con personas que no conoces previamente? ¿Por qué?
- ¿Te interesaría usar el deporte como una forma de conocer nuevas personas y ampliar tu círculo social?
- ¿Qué opinas sobre una aplicación que te permita reservar espacios para fútbol o billar de forma rápida y sencilla?
- ¿Qué funciones te gustaría ver en una aplicación que te ayude a gestionar tus reservas deportivas?
- ¿Cómo te gustaría que se maneje la comunicación dentro de la aplicación (chat en tiempo real, notificaciones, etc.)?
- Sabiendo que la aplicación estará disponible tanto en versión web como móvil, ¿en cuál te sentirías más cómodo haciendo tus reservas y por qué?


**Para segmento 2:**

- ¿Cuántos espacios deportivos tienes disponibles?
- ¿Cómo manejas actualmente las reservas para tus espacios deportivos?
- ¿Qué problemas enfrentas en la promoción y llenado de tus espacios deportivos?
- ¿Cómo promocionas actualmente tus espacios deportivos para atraer jugadores?
- ¿Qué medios utilizas para llegar a nuevos clientes (redes sociales, publicidad, etc.)?
- ¿Cómo ha sido tu experiencia promocionando tus espacios deportivos?
- ¿Qué día de la semana experimentas la menor afluencia de reservas para tus espacios deportivos?
- ¿Qué te motivaría a usar una aplicación para promocionar y gestionar las reservas de tus espacios deportivos?
- ¿Qué características te gustaría que la aplicación ofreciera para facilitar la gestión de tus reservas y la promoción de tus espacios?
- ¿Qué tecnología consideras beneficiosa para controlar el acceso a tus espacios deportivos?
- ¿Qué tipo de reportes o estadísticas te gustaría recibir sobre el uso de tus espacios deportivos a través de la aplicación?
- ¿Qué dudas o preocupaciones tendrías al usar una nueva plataforma para la promoción y gestión de las reservas de tus espacios deportivos?
- ¿Qué tipo de soporte o asistencia esperas recibir de la plataforma en caso de problemas o inconvenientes?


</div>

### 2.2.2. Registro de entrevistas

<div style="text-align: justify;">

Link de las entrevistas en anexos

Entrevista N°1:

<img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//entrevistado1.png" alt="UPC">

- **Entrevistador:** Clara Valverde Salazar
- **Entrevistado:** Rafael Arturo Luyo Ramor
- **Sexo:** Masculino
- **Edad:** 23 años
- **Distrito:** Santiago de Surco
- **Duracion de la entrevista:** 6:00 minutos
- **Link:** https://www.youtube.com/watch?v=kszWqAHkT_g 
- **Resumen:** Rafael es un estudiante universitario de Ingeniería de Software. Actualmente trabaja de lunes a viernes, y durante los fines de semana suele dedicar tiempo a jugar billar, una de sus actividades recreativas favoritas.
	Comenta que organizar partidas le resulta complicado, ya que utiliza WhatsApp para coordinar con otras personas, pero no siempre encuentra jugadores disponibles. Rafael reserva mesas de billar aproximadamente cinco veces al mes, y valora especialmente la calidad y la disponibilidad del espacio, aspectos que considera fundamentales para garantizar la comodidad tanto para él como para sus amigos.	Durante la entrevista, manifestó interés en contar con una aplicación que le facilite la búsqueda de personas disponibles para jugar. Le gustaría que esta app permitiera realizar reservas de manera sencilla y que incluyera funciones como chat en tiempo real y notificaciones automáticas, que le recuerden sus partidas programadas. Por motivos de conveniencia, Rafael prefiere una versión móvil de la aplicación, ya que le resulta más accesible y práctica para su estilo de vida.

Entrevista N°2:

<img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//entrevistado2.png" alt="UPC">

- **Entrevistador:** Clara Valverde Salazar
- **Entrevistado:** Daniel Rodrigo Chillos Arevalos
- **Sexo:** Masculino
- **Edad:** 30 años
- **Distrito:** Comas
- **Duracion de la entrevista:** 7:17 minutos
- **Link:** https://youtu.be/J84R3rz9o1I
- **Resumen:** Daniel es un estudiante universitario que administra un local con cinco mesas de billar, actividad que combina con sus estudios y su afición al juego. Actualmente gestiona las reservas mediante WhatsApp y llamadas telefónicas, pero enfrenta dificultades para atraer nuevos clientes y realizar promociones efectivas, a pesar de utilizar Instagram y WhatsApp como canales de difusión. Menciona que los días con menor afluencia son lunes y martes, por lo que le interesaría contar con una aplicación que le permita gestionar reservas en línea, enviar recordatorios automáticos, integrar un calendario, y ofrecer herramientas para promociones y descuentos. También desea que la app proporcione reportes sobre la ocupación de los espacios, clientes frecuentes, y efectividad de las promociones. Sin embargo, le preocupa que la aplicación no sea lo suficientemente intuitiva para él o sus clientes, y considera importante contar con soporte técnico vía telefónica.

Entrevista N°3:

<img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//entrevistado3.png" alt="UPC">

- **Entrevistador:** Clara Valverde Salazar
- **Entrevistado:** Danny Cao Cao
- **Sexo:** Masculino
- **Edad:** 22 años
- **Distrito:** Jesus Maria
- **Duracion de la entrevista:** 5:15 minutos
- **Link:** https://youtu.be/OK2F5G7bt28
- **Resumen:** Danny es un estudiante universitario de Ingeniería de Minas que practica fútbol entre dos y tres veces por semana. Aunque utiliza la plataforma web “Deport Plaza” para reservar espacios deportivos, enfrenta dificultades para coordinar horarios con sus compañeros, lo que limita la frecuencia de sus partidos. Valora especialmente la ubicación y la calidad del campo al momento de hacer una reserva, y muestra interés en conocer nuevas personas a través del deporte.
Le atrae la idea de una aplicación móvil que le permita realizar reservas con facilidad, que le notifique sobre la disponibilidad de canchas con detalles específicos, y que utilice notificaciones como medio de comunicación principal. Para él, una versión móvil resulta ideal por la practicidad de llevarla en su celular.

Entrevista N°4:

<img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//entrevistado4.png" alt="UPC">

- **Entrevistador:** Clara Valverde Salazar
- **Entrevistado:** Jose Luis Figeroa
- **Sexo:** Masculino
- **Edad:** 36 años
- **Distrito:** Rimac
- **Duracion de la entrevista:** 5:22 minutos
- **Link:** https://youtu.be/krUlDn7nS3U
- **Resumen:** José Luis es estudiante de Ingeniería de Sistemas y disfruta jugar billar con sus amigos los fines de semana. Sin embargo, le resulta difícil coordinar horarios, ya que organiza sus partidas a través de WhatsApp y enfrenta problemas con la disponibilidad de todos. Valora mucho la calidad del espacio y la disponibilidad para hacer reservas, aunque se siente incómodo realizando reservas por teléfono. Está interesado en conocer nuevas personas a través del billar y le atrae la idea de una aplicación que le facilite hacer reservas. Le gustaría que la app incluyera funciones como tiempo de juego y notificaciones, y prefiere que la comunicación dentro de la aplicación sea mediante chat en tiempo real. Además, le resultaría conveniente que la aplicación estuviera disponible en versión móvil para mayor accesibilidad.

Entrevista N°5:

<img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//entrevistado5.png" alt="UPC">

- **Entrevistador:** Clara Valverde Salazar
- **Entrevistado:** Julio Cesar Matos
- **Sexo:** Masculino
- **Edad:** 21 años
- **Distrito:** Callao
- **Duracion de la entrevista:** 9:54 minutos
- **Link:** https://youtu.be/P41ssO3nYIk 
- **Resumen:** Julio es estudiante de Ingeniería de Sistemas y administra tres losas deportivas para fútbol. Actualmente gestiona las reservas de forma presencial, ya que los clientes suelen acudir a su casa, o lo contactan por WhatsApp para consultar la disponibilidad. Enfrenta dificultades para completar reservas entre semana (de lunes a viernes) y ha tenido problemas por la duplicación de horarios, lo que genera conflictos entre grupos. Además, no realiza publicidad, lo que limita su alcance a nuevos clientes. Está interesado en una aplicación intuitiva que le permita gestionar reservas de manera más eficiente. Valora especialmente que se integren métodos de pago modernos como Yape y tarjetas de crédito. También le gustaría contar con reportes sobre afluencia semanal, reservas sin confirmar y el porcentaje de clientes que completan el proceso de reserva.

Entrevista N°6:

<img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//entrevistado6.png" alt="UPC">

- **Entrevistador:** Willy Valentin
- **Entrevistado:** Diego Portales
- **Sexo:** Masculino
- **Edad:** 24 años
- **Distrito:** Pueblo Libre
- **Duracion de la entrevista:** 5:40 minutos
- **Link:** https://upcedupe-my.sharepoint.com/:v:/g/personal/u20201c037_upc_edu_pe/ERU-1RConSZPq2oXjv1ezzgBt-yZozxww0fFwOGDqho1sw?e=gB4hhP&nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJTdHJlYW1XZWJBcHAiLCJyZWZlcnJhbFZpZXciOiJTaGFyZURpYWxvZy1MaW5rIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXcifX0%3D
- **Resumen:** Diego tiene 24 años y vive en Pueblo Libre. Actualmente, es estudiante y su día a día suele asistir a la universidad e ir a las prácticas en la mañana. Jugaba fútbol con sus amigos, juega con poca frecuencia. Generalmente, uno de sus amigos contactaba para separar la cancha, él valora principalmente la ubicación, la calidad y la reputación del lugar. La forma de reserva era por WhatsApp, y que no sería cómodo no encontrar. A él le ayudaría bastante un aplicativo que le ahorre tiempo reservar, y sí le gustaría participar con personas desconocidas como forma de ampliar su círculo social. Finalmente, él cree que sería útil la aplicación para reservar canchas deportivas y que cuente con funcionalidades como mapas, métodos de pago fáciles y tener un chat en vivo, asimismo, él se sentiría más cómodo usar la versión móvil porque es más fácil de llevar.

Entrevista N°7:

<img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//entrevistado7.png" alt="UPC">

- **Entrevistador:** Willy Valentin
- **Entrevistado:** Johan Moreno
- **Sexo:** Masculino
- **Edad:** 24 años
- **Distrito:** Ate
- **Duracion de la entrevista:** 6:50 minutos
- **Link:** https://upcedupe-my.sharepoint.com/:v:/g/personal/u20201c037_upc_edu_pe/EVUb74RsD2ZLvFcTN4UnNnkBxhPuRb6X4dAd6RYSG1O4Jw?e=aif5Md&nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJTdHJlYW1XZWJBcHAiLCJyZWZlcnJhbFZpZXciOiJTaGFyZURpYWxvZy1MaW5rIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXcifX0%3D
- **Resumen:** Johan, tiene 24 años y vive en Ate. Actualmente, él es estudiante, en las noches terminando sus labores de la universidad entrena. Él juega usualmente los sábados, uno de los problemas es que no pueden coordinar bien con sus amigos, ellos utilizan WhatsApp para poder organizar. Las dificultades encontradas son la confirmación de sus amigos y la disponibilidad de las canchas. Él valora principalmente la calidad del espacio, que tenga camerinos, duchas e implementos de limpieza. Ellos hacen la reserva por WhatsApp donde también confirman el pago por ese medio, pero hay veces en las que el dueño no contesta rápido. A Johan le gustaría ver la disponibilidad en tiempo real para no esperar que el dueño responda, él prefiere jugar con amigos que con desconocidos y que le parece una buena forma de socializar. Finalmente, a Johan le parece que le ayudaría bastante una aplicación de reservas de campos deportivos porque le facilitarían bastante y le gustaría que haya un asesor si en caso haya algún problema en el uso del aplicativo, además, él se sentiría más cómodo utilizar la versión móvil porque siempre lo carga.

Entrevista N°8:

<img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//entrevistado8.png" alt="UPC">

- **Entrevistador:** Willy Valentin
- **Entrevistado:** Miguel Ybañez
- **Sexo:** Masculino
- **Edad:** 22 años
- **Distrito:** Rimac
- **Duracion de la entrevista:** 7:50 minutos
- **Link:** https://upcedupe-my.sharepoint.com/:v:/g/personal/u20201c037_upc_edu_pe/EYn0uP1NAthHnGIz6xMYk94BFrnF2-7Pmrev69Shoah8JQ?e=tkRb9k&nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJTdHJlYW1XZWJBcHAiLCJyZWZlcnJhbFZpZXciOiJTaGFyZURpYWxvZy1MaW5rIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXcifX0%3D
- **Resumen:** Miguel tiene 22 años y vive en Rimac. Actualmente, él estudia en las mañanas, algunos días va a trabajar y suele jugar fútbol pocas veces pero sí suele encontrarse con sus amigos como 3 veces al mes. Ellos organizan por el medio de WhatsApp o Facebook, entre las dificultades que tuvo fue la disponibilidad de los campos deportivos. Miguel reserva 2 veces al mes y él valora más la ubicación para que esté más cercano para todos los asistentes, y realizan su reserva por medio de llamadas pero hay algunos casos que no le gusta reservar de forma presencial. A él le gustaría ver en tiempo real la disponibilidad de los campos para mejorar la coordinación con sus amigos, a él le gusta jugar más con sus amigos que con desconocidos. Miguel si le gusta la idea de crecer su círculo social mediante el deporte, y le parece que una aplicación que le ayude a reservar le sería de gran ayuda para ver los campos y se adecue a tu ubicación, asimismo, le gustaría que se comuniquen por medio de chat en tiempo real. Finalmente, a él le gustaría utilizar en la versión móvil porque siempre lo tiene a la mano.

Entrevista N°9:

<img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//entrevistado9.png" alt="UPC">

- **Entrevistador:** Willy Valentin
- **Entrevistado:** Alexis Patasca 
- **Sexo:** Masculino
- **Edad:** 26 años
- **Distrito:** Los Olivos
- **Duracion de la entrevista:** 5:00 minutos
- **Link:** https://upcedupe-my.sharepoint.com/:v:/g/personal/u20201c037_upc_edu_pe/EemPNqNHDUVEn8hmuBcpUEAB0OQ-8hqMND6x_j1LtLDluQ?e=XYyu2f&nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJTdHJlYW1XZWJBcHAiLCJyZWZlcnJhbFZpZXciOiJTaGFyZURpYWxvZy1MaW5rIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXcifX0%3D 
- **Resumen:** Alexis tiene 26 años y vive en Los Olivos. Actualmente, es estudiante y suele ayudar a un familiar que alquila 4 campos deportivos que son 3 de fútbol y 1 de vóley, la reserva lo hacen por llamada y presencial. Los principales problemas que enfrentan es la equivocación con los horarios, pues esto afecta a las personas que habían reservado. Ellos utilizan las redes sociales para la publicidad de su servicio, asimismo, él se dio cuenta los martes y miércoles no hay tantas personas que reserven. Finalmente, a él le gustaría que una aplicación le muestre estadísticas como la cantidad de reservas diarias, además, cree que quizás algunos trabajadores no puedan adaptarse al aplicativo, y él espera la asistencia rápida con ellos para que los puedan apoyar en casos de que haya problemas.

Entrevista N°10:

<img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//entrevistado10.png" alt="UPC">

- **Entrevistador:** Willy Valentin
- **Entrevistado:** Oscar Soto 
- **Sexo:** Masculino
- **Edad:** 25 años
- **Distrito:** Santiago de Surco
- **Duracion de la entrevista:** 5:57 minutos
- **Link:** https://upcedupe-my.sharepoint.com/:v:/g/personal/u20201c037_upc_edu_pe/ER2BxBfK_zBHgx0Y0_DDm4oBVhDbgjAgiyN1WABJM9RnDg?e=faGlFb&nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJTdHJlYW1XZWJBcHAiLCJyZWZlcnJhbFZpZXciOiJTaGFyZURpYWxvZy1MaW5rIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXcifX0%3D
- **Resumen:** Oscar tiene 25 años y vive en Santiago de Surco. Actualmente, él se encuentra administrando 2 espacios deportivos de fútbol y vóley. Oscar administra de manera manual usando un cuaderno para gestionar las reservas, el principal problema es que a veces hay errores de agrupación de reservas. Generalmente, la publicidad es por las recomendaciones de sus clientes, en las redes sociales fue muy baja la retención de clientes, además, Oscar vio que los primeros días de la semana no reservan tanto. A Oscar le gustaría que una aplicación le muestre en tiempo real la disponibilidad de las canchas para que los clientes puedan buscar horarios disponibles, asimismo, a él le gustaría recibir un reporte de cuantas personas asisten a sus campos deportivos y tendría la duda que no se actualice los espacios disponibles para no generar confusión en los clientes. Finalmente, a él le gustaría que la aplicación no se detuviera para que no se junten tantos clientes y no haya un mal momento.

### 2.2.3. Analisis de entrevistas

<div style="text-align: justify;">

**Segmento 1:**

Las entrevistas realizadas a jugadores aficionados, tanto al fútbol como al billar, revelan una serie de frustraciones comunes relacionadas principalmente con la coordinación para reservar espacios deportivos. Muchos dependen de WhatsApp o llamadas telefónicas, lo cual genera desorganización y demoras al no saber si hay disponibilidad real hasta que el administrador responde. Además, organizarse con amigos suele ser complicado por la falta de coincidencia de horarios y respuestas tardías. A pesar de que algunos han utilizado plataformas como Deport Plaza, todavía encuentran limitaciones en cuanto a facilidad de uso, cobertura o funcionalidades.

Los aspectos que más valoran al momento de reservar son la calidad del espacio, la ubicación, la disponibilidad clara y la comodidad del proceso. Existe un fuerte interés en una solución tecnológica, específicamente una aplicación móvil, que les permita ver disponibilidad en tiempo real, reservar en segundos, coordinar mediante chat interno, recibir notificaciones y organizar mejor su tiempo libre. Adicionalmente, algunos usuarios muestran apertura a socializar con nuevas personas a través del deporte, por lo que incluir funciones de “match deportivo” podría ser un valor agregado interesante en el mediano plazo.

**Segmento 2:**

Por el lado de los propietarios, los hallazgos apuntan a una gestión operativa manual y vulnerable. Actualmente utilizan cuadernos, llamadas o mensajes de WhatsApp para controlar reservas, lo cual ha derivado en errores como la duplicación de horarios o la pérdida de información importante. También enfrentan una baja afluencia durante ciertos días (como lunes y martes), y no tienen herramientas para evaluar por qué o cómo solucionarlo. Aunque algunos promueven sus servicios por redes sociales, no logran atraer nuevos clientes de forma sostenida, y carecen de indicadores que les ayuden a mejorar su gestión comercial.

Estos propietarios valoran mucho la posibilidad de contar con una aplicación que les permita centralizar su operación, visualizar reservas en tiempo real, recibir pagos mediante plataformas como Yape o tarjetas, y generar reportes sobre afluencia, comportamiento de clientes y efectividad de promociones. Sin embargo, expresan una preocupación importante sobre la facilidad de uso de la herramienta, tanto para ellos como para el personal a su cargo, y consideran esencial contar con soporte técnico accesible y confiable que los ayude a adaptarse sin complicaciones.

**Conclusiones:**

Las entrevistas realizadas dejan clara una necesidad compartida de digitalizar y formalizar el proceso de reservas deportivas, tanto desde la perspectiva del usuario como del administrador. Existe una gran oportunidad para que D’Taquito se posicione como una plataforma tecnológica que mejore radicalmente la experiencia de ambos públicos, permitiéndoles organizarse con mayor eficiencia, tener acceso a datos relevantes en tiempo real y fomentar una comunidad en torno al deporte. El enfoque debe contemplar tanto una interfaz intuitiva para usuarios que buscan reservar, como un panel administrativo funcional y simple para los encargados de los espacios deportivos.

Además, la versión móvil es vista como el canal más conveniente por todos los actores, lo que implica que el desarrollo debe enfocarse en "mobile-first". A nivel funcional, la app no solo debe ofrecer reservas, sino convertirse en una herramienta de gestión, promoción, comunicación y análisis. Finalmente, para asegurar una correcta adopción, se debe considerar una estrategia de soporte técnico y educación digital para los propietarios, especialmente aquellos menos familiarizados con la tecnología.

</div>

## 2.3. Needfinding

</div>

### 2.3.1. User Personas

<div style="text-align: justify;">

**Segmento 1: Personas que practica futbol y/o billar**

<img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//userpersona-player.png" alt="UPC">

**Segmento 2: Personas dueñas de un espacio deportivo** 

<img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//userpersona-owner.png" alt="UPC">

</div>

### 2.3.2. User Task Matrix

<div style="text-align: justify;">

**Segmento 1: Personas que practica futbol y/o billar**

| Actividades                                       | Frecuencia | Importancia |
| :------------------------------------------------ | :--------: | :----------: |
| Buscar espacios deportivos disponibles en la ciudad |   Alta   |     Alta     |
| Consultar con amigos sobre su disponibilidad de juego |   Alta   |     Alta     |
| Revisar horarios de los espacios deportivos       |   Media  |     Alta     |
| Coordinar con amigos para formar un grupo de juego |   Alta   |     Alta     |
| Ver los horarios disponibles de los espacios deportivos |   Media  |     Alta     |
| Visitar físicamente los espacios deportivos para conocerlos |   Baja   |    Media     |
| Decidir entre varias opciones de espacios deportivos |   Media  |     Alta     |
| Realizar pagos restantes de reserva en persona     |   Media  |    Media     |


**Segmento 2: Personas dueñas de un espacio deportivo** 

| Actividades                                          | Frecuencia | Importancia |
| :--------------------------------------------------- | :--------: | :----------: |
| Promocionar los espacios deportivos en redes sociales |   Media  |     Alta     |
| Coordinar reservas por teléfono o redes sociales     |   Alta   |     Alta     |
| Gestionar la disponibilidad de las instalaciones    |   Media  |     Alta     |
| Manejar cancelaciones y reprogramaciones             |   Media  |    Media     |
| Realizar campañas de publicidad local para atraer clientes |   Baja   |    Media     |
| Recolectar pagos de clientes en persona o por transferencia |   Media  |    Media     |
| Hacer seguimiento a la satisfacción de los clientes |   Baja   |     Baja     |
| Mantener las instalaciones en condiciones óptimas     |   Baja   |    Media     |

</div>

### 2.3.3. User Journey Mapping

<div style="text-align: justify;">

**User persona 1: Andres Martinez**

<img src="https://raw.githubusercontent.com//HenryCenturion//open-source-final-project//develop//informe//images//journey2.png" alt="UPC">

**User persona 2: Juan Perez**

<img src="https://raw.githubusercontent.com//HenryCenturion//open-source-final-project//develop//informe//images//journey3.png" alt="UPC">

</div>

### 2.3.4. Empathy Mapping

<div style="text-align: justify;">

**User persona 1: Andres Martinez**

<img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//empathy-player.png" alt="UPC">

**User persona 2: Juan Perez**

<img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//empathy-owner.png" alt="UPC">

</div>

### 2.3.5. As Is Scenario Mapping

<div style="text-align: justify;">

**User persona 1: Andres Martinez**  

<img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//asis-player.jpg" alt="UPC">

**User persona 2: Juan Perez**

<img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//asis-owner.jpg" alt="UPC">

</div>

### 2.4. Ubiquitous Language

<div style="text-align: justify;">

- **Jugador**:
   - Persona que interactúa con el sistema de reservas para reservar un espacio deportivo.
- **Propietario**:
   - Persona que es dueña de un espacio deportivo y pone a disposición su local para su alquiler. 
- **Administrador**:
    - Usuario encargado de gestionar los tickets de retiro y mantener el sistema funcionando correctamente.
- **Reserva**:
    - Acción realizada por un jugador para ocupar un espacio deportivo en un horario específico.
- **Créditos**:
    - Moneda virtual del sistema que los jugadores usan para reservar espacios y que los propietarios reciben como ganancia.
- **Recarga de créditos**:
    - Proceso mediante el cual un jugador añade créditos a su cuenta mediante una pasarela de pago (por ejemplo, PayPal Sandbox).
- **Suscripción**:
    - Acción del propietario para habilitar su cuenta y poder ofrecer espacios deportivos. Se realiza mediante un pago.
- **Ticket de retiro**:
    - Solicitud creada por el propietario para que el administrador procese el retiro de sus créditos.
- **Chat de sala**:
    - Sistema de mensajería donde los jugadores pueden comunicarse mientras participan en una sala de juego.
- **Sala de juego**:
    - Espacio virtual donde varios jugadores pueden compartir el uso de un espacio deportivo, como un partido comunitario.
- **Interfaz responsiva**:
    - Diseño adaptable a distintos dispositivos (desktop, móvil), especialmente útil para el chat y sidebar.

</div>

# III. Requirements Specification

## 3.1. To-Be Scenario Mapping

<div style="text-align: justify;">

**User persona 1: Andres Martinez**  

<img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//tobe-player.png" alt="UPC">

**User persona 2: Juan Perez**

<img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//tobe-owner.png" alt="UPC">
</div>

## 3.2. User Stories

| Categoría     | Epic ID | Título                                 | Descripción                                                                                                   | Relacionado con (Story ID)                     |
|---------------|---------|-----------------------------------------|---------------------------------------------------------------------------------------------------------------|------------------------------------------------|
| **Frontend**  | EP01    | Gestión de cuentas de usuario           | Como jugador o propietario quiero gestionar la creación y uso de mi cuenta para acceder a mi información     | US01, US02, US03, US04, US05, US23                   |
|   **Frontend**            | EP02    | Gestión de suscripciones                | Como propietario quiero gestionar mi suscripción para adecuarla sus beneficios según mis necesidades         | US06, US07                                     |
| **Frontend**  | EP03    | Gestión de espacios deportivos          | Como jugador o propietario quiero gestionar los espacios deportivos para visualizarlos                       | US08, US09, US10, US11                         |
| **Frontend**  | EP04    | Gestión de reservas                     | Como jugador quiero gestionar la creación de reservas para jugar en los espacios deportivos                   | US12, US13, US14, US15                                     |
| **Frontend**  | EP05    | Gestión de salas comunidad              | Como jugador quiero gestionar la creación de salas comunidad para conocer nuevas personas con quienes jugar | US16, US17, US18, US19, US20                        |
| **Frontend**  | EP06    | Gestión de tickets para transferencia    | Como propietario quiero gestionar mis tickets de transferencia para obtener mis ganancias                     | US21, US22         |
| **Landing Page** | EP07    | Elementos de landing page               | Como visitante quiero visualizar el contenido resaltante del landing page para conocer sobre la aplicación   | US24                                           |
| **Backend**   | EP08    | Implementación del módulo users         | Como desarrollador quiero implementar las funcionalidades esenciales para que el módulo users funcione      | TS01, TS02, TS03, TS04, TS05, TS06, TS35, TS36 |
| **Backend**   | EP09    | Implementación del módulo auth/iam      | Como desarrollador quiero implementar las funcionalidades esenciales para que el módulo iam funcione        | TS07, TS08, TS09                               |
| **Backend**   | EP10    | Implementación del módulo subscriptions | Como desarrollador quiero implementar las funcionalidades esenciales para que el módulo subscriptions funcione | TS10, TS11                                  |
| **Backend**   | EP11    | Implementación del módulo sportspaces   | Como desarrollador quiero implementar las funcionalidades esenciales para que el módulo sportspaces funcione | TS12, TS13, TS14, TS15                      |
| **Backend**   | EP12    | Implementación del módulo reservations  | Como desarrollador quiero implementar las funcionalidades esenciales para que el módulo reservations funcione | TS16, TS17, TS18, TS19, TS20                |
| **Backend**   | EP13    | Implementación del módulo playerlists   | Como desarrollador quiero implementar las funcionalidades esenciales para que el módulo playerlists funcione | TS21, TS22                                  |
| **Backend**   | EP14    | Implementación del módulo chatroom      | Como desarrollador quiero implementar las funcionalidades esenciales para que el módulo chatroom funcione    | TS23                                           |
| **Backend**   | EP15    | Implementación del módulo deposit       | Como desarrollador quiero implementar las funcionalidades esenciales para que el módulo deposit funcione     | TS24, TS25                                     |
| **Backend**   | EP16    | Implementación del módulo banktransfer  | Como desarrollador quiero implementar las funcionalidades esenciales para que el módulo banktransfer funcione | TS26, TS27, TS28, TS29                      |
| **Backend**   | EP17    | Implementación del módulo rooms         | Como desarrollador quiero implementar las funcionalidades esenciales para que el módulo rooms funcione       | TS30, TS31, TS32, TS33, TS34                   |

<br>
<br>
<br>

|User Story ID|Título|Descripción|Criterio de aceptación|<p>Relación (EPIC ID)</p><p></p>|
| :-: | :-: | :-: | :-: | :-: |
|US01|Registro de cuenta de usuario|Como jugador o propietario quiero registrarme para tener una cuenta en D'Taquito|<p>***Escenario 1: Registro de cuenta exitoso de usuario***</p><p></p><p>Dado que el usuario se encuentra en la pantalla de registro de cuenta</p><p>Cuando el usuario ingresa los datos de su registro de cuenta completos y correctos en los campos: nombre, correo electrónico, contraseña y rol</p><p>Y hace clic en el botón “Registrarse”</p><p>Entonces la aplicación crea la cuenta para el usuario</p><p></p><p>***Escenario 2: Registro de cuenta fallido de usuario***</p><p></p><p>Dado que el usuario se encuentra registrado en la aplicación</p><p>Cuando el usuario se encuentra en la pantalla de inicio de sesión</p><p>Y escribe correctamente su correo y su contraseña</p><p>Y haga clic en el botón "iniciar sesión"</p><p>Entonces la aplicación llevará al usuario a la página principal</p><p>***Escenario 3: Registro de cuenta fallido por un correo ya registrado***</p><p></p><p>Dado que el usuario se encuentra en la pantalla de registro de cuenta</p><p>Cuando el usuario ingresa los datos de su registro de cuenta completos y correctos en los campos: nombre, correo electrónico, contraseña y rol</p><p>Y hace clic en el botón “Registrarse”</p><p>Entonces la aplicación muestra un mensaje de error indicando que ya existe un correo en uso</p>|EP01|
|US02|Inicio de sesión de cuenta|Como jugador o propietario quiero ingresar a mi cuenta para usar de las funcionalidades de la aplicación D’Taquito|<p>***Escenario 1: Inicio de sesión exitoso***</p><p></p><p>Dado que el usuario se encuentra registrado en la aplicación.</p><p>Cuando el usuario se encuentra en la pantalla de inicio de sesión</p><p>Y escribe correctamente su correo y su contraseña</p><p>Y haga clic en el botón "iniciar sesión"</p><p>Entonces la aplicación llevará al usuario a la página principal</p><p></p><p>***Escenario 2: Inicio de sesión fallido***</p><p></p><p>Dado que el usuario se encuentra registrado en la aplicación</p><p>Cuando el usuario se encuentra en la pantalla de inicio de sesión</p><p>Y escribe incorrectamente su correo y/o su contraseña</p><p>Y haga clic en el botón "iniciar sesión"</p><p>Entonces la aplicación notifica que se ingresaron incorrectamente los datos</p>|EP01|
|US03|Ver perfil de usuario|Como jugador o propietario quiero acceder a mi perfil para visualizar mis datos personales|<p>***Escenario 1: Acceso a perfil***</p><p></p><p>Dado que el usuario se encuentra autenticado</p><p>Cuando da clic al icono de perfil en la parte del toolbar</p><p>Y selecciona el apartado perfil</p><p>Entonces, la aplicación muestra la información de perfil del usuario</p>|EP01|
|US04|Editar perfil de usuario|Como usuario jugador o propietario quiero acceder a mi perfil para editar mis datos personales|<p>***Escenario 1: Edición de información correcta***</p><p></p><p>Dado que el usuario se encuentra autenticado</p><p>Cuando está en la pantalla de perfil</p><p>Y da clic en el botón "Editar información" en el campo deseado</p><p>Y edita su información</p><p>Y da clic en el botón “Guardar”</p><p>Entonces la aplicación actualiza la información del usuario</p><p></p><p>|EP01|
|US05|Recargar crédito|Como jugador quiero recargar crédito para reservar un espacio deportivo|<p>***Escenario 1: Recarga de crédito exitosa***</p><p>Dado que el jugador se encuentra autenticado en la aplicación</p><p>Cuando está en la pantalla de perfil</p><p>Y da clic en el botón “Recargar créditos”</p><p>Y escribe la cantidad de crédito deseada</p><p>Y paga con una cuenta de PayPal válida con saldo suficiente</p><p>Entonces la recarga será exitosa y se visualizará la cantidad nueva de créditos</p><p></p><p>***Escenario 2: Recarga de crédito fallida***</p><p>Dado que el jugador se encuentra autenticado en la aplicación</p><p>Y está en la pantalla de perfil</p><p>Cuando da clic en el botón “Recargar créditos”</p><p>Y escribe la cantidad de crédito deseada</p><p>Y no paga con una cuenta de PayPal válida con saldo suficiente</p><p>Entonces la recarga fallará y mostrará un error</p>|EP01|
|US06|Ver una suscripción|Como propietario quiero ver el estado de mi suscripción para gestionarla|<p>***Escenario 1: Visualizar suscripción***</p><p>Dado que el propietario se encuentra autenticado</p><p>Cuando da clic al botón “Suscripciones” ubicado en el toolbar</p><p>Entonces la aplicación visualiza la suscripción actual del propietario</p>|EP02|
|US07|Actualizar una suscripción|Como usuario propietario quiero actualizar mi suscripción para usar los beneficios que me da|<p>***Escenario 1: Éxito al actualizar la suscripción***</p><p>Dado que el propietario se encuentra autenticado en la aplicación</p><p>Cuando se encuentra en la pantalla de suscripciones</p><p>Y da clic al icono de comprar en la suscripción deseada</p><p>Y paga con una cuenta de PayPal válida con saldo suficiente</p><p>Entonces la aplicación actualiza la suscripción del propietario</p><p>***Escenario 2: Error al adquirir la suscripción***</p><p>Dado que el propietario se encuentra autenticado en la aplicación</p><p>Cuando se encuentra en la pantalla de suscripciones</p><p>Y da clic al icono de comprar en la suscripción deseada</p><p>Y no paga con una cuenta de PayPal válida con saldo suficiente</p><p>Entonces la aplicación no actualiza la suscripción del propietario</p>|EP02|
|US08|Visualizar espacios deportivos|Como jugador o propietario quiero ver los espacios deportivos que existen en la aplicación para conocer sus detalles|<p>***Escenario 1: Visualizar espacios deportivos siendo jugador***</p><p>Dado que el jugador se encuentra autenticado</p><p>Cuando da clic al botón "Espacios deportivos" ubicado en el toolbar</p><p>Entonces la aplicación muestra todos los espacios deportivos</p><p>***Escenario 2: Visualizar espacios deportivos siendo propietario***</p><p>Dado que el propietario se encuentra autenticado</p><p>Cuando da clic al botón "Espacios deportivos" ubicado en el toolbar</p><p>Entonces la aplicación muestra sus espacios deportivos registrados</p>|EP03|
|US09|Añadir un espacio deportivo|Como propietario de un espacio deportivo quiero añadir mi espacio deportivo a la aplicación para que los jugadores puedan visualizarlo|<p>***Escenario 1: Éxito al añadir un espacio deportivo***</p><p>Dado que el propietario se encuentra autenticado en la aplicación</p><p>Cuando se encuentra en la pantalla de espacios deportivos</p><p>Y da clic a “Añadir espacio deportivo”</p><p>Y es lunes entre las 00:00 y 06:00 horas</p><p>Y registra todos los datos solicitados en los campos: nombre, deporte, imagen, precio, distrito, dirección, descripción, hora de apertura, hora de cierre y modo de juego</p><p>Y da clic en “Confirmar”</p><p>Entonces la aplicación añade el espacio deportivo en la plataforma</p><p>***Escenario 2: Error al añadir un espacio deportivo***</p><p>Dado que el propietario se encuentra autenticado en la aplicación</p><p>Cuando se encuentra en la pantalla de espacios deportivos</p><p>Y da clic a “Añadir espacio deportivo”</p><p>Y no es lunes entre las 00:00 y 06:00 horas</p><p>Entonces la aplicación muestra un mensaje de error, indicando la hora de disponibilidad para agregar espacio deportivo</p>|EP03|
|US10|Eliminar un espacio deportivo|Como propietario de un espacio deportivo quiero eliminar mi espacio deportivo porque ya quiero que esté registrado|<p>***Escenario 1: Éxito al eliminar un espacio deportivo***</p><p>Dado que el propietario se encuentra autenticado en la aplicación</p><p>Cuando se encuentra en la pantalla de espacios deportivos</p><p>Y selecciona uno de sus espacios deportivos</p><p>Y da clic en el ícono “Eliminar”</p><p>Y es lunes entre las 00:00 y 06:00 horas</p><p>Y da clic en “Confirmar”</p><p>Entonces la aplicación elimina el espacio deportivo de la plataforma</p><p>***Escenario 2: Error al eliminar un espacio deportivo***</p><p>Dado que el propietario se encuentra autenticado en la aplicación</p><p>Cuando se encuentra en la pantalla de espacios deportivos</p><p>Y selecciona uno de sus espacios deportivos</p><p>Y da clic en el ícono “Eliminar”</p><p>Y no es lunes entre las 00:00 y 06:00 horas</p><p>Entonces la aplicación muestra un mensaje de error, indicando la hora de disponibilidad para editar un espacio deportivo</p>|EP03|
|US11|Aplicar filtros para búsqueda de espacios deportivos|Como jugador quiero aplicar filtros para encontrar espacios deportivos según mis preferencias|<p>***Escenario 1: Filtrar espacios deportivos según deporte***</p><p>Dado que el jugador se encuentra autenticado en la aplicación</p><p>Cuando se encuentra en la pantalla de espacios deportivos</p><p>Y selecciona el filtro por deporte</p><p>Y selecciona “Fútbol” o “Billar”</p><p>Entonces la aplicación muestra los espacios deportivos que coincidan con el deporte elegido</p><p>***Escenario 2: Filtrar espacios deportivos según distrito***</p><p>Dado que el jugador se encuentra autenticado en la aplicación</p><p>Cuando se encuentra en la pantalla de espacios deportivos</p><p>Y selecciona el filtro por distrito</p><p>Y elige un distrito de Lima Metropolitana</p><p>Entonces la aplicación muestra los espacios deportivos ubicados en el distrito seleccionado</p><p>***Escenario 3: Filtrar espacios deportivos según precio***</p><p>Dado que el jugador se encuentra autenticado en la aplicación</p><p>Cuando se encuentra en la pantalla de espacios deportivos</p><p>Y selecciona el filtro por precio</p><p>Y establece un valor mínimo y/o máximo</p><p>Entonces la aplicación muestra los espacios deportivos cuyo precio esté dentro del rango definido</p><p>***Escenario 4: Filtrar espacios deportivos según rango de horario***</p><p>Dado que el jugador se encuentra autenticado en la aplicación</p><p>Cuando se encuentra en la pantalla de espacios deportivos</p><p>Y selecciona el filtro por horario</p><p>Y elige una hora de apertura y/o una hora de cierre</p><p>Entonces la aplicación muestra los espacios deportivos que tienen disponibilidad dentro del rango de horario seleccionado</p>|EP03|
|US12|Visualizar horas disponibles de un espacio deportivo|Como jugador quiero visualizar las horas disponibles de un espacio deportivo para reservar|<p>***Escenario 1: Visualizar reservas de un espacio deportivo***</p><p>Dado que el jugador se encuentra autenticado en la aplicación</p><p>Cuando se encuentra en la pantalla de espacios deportivos</p><p>Y da clic en el botón “Conocer más” de un espacio deportivo</p><p>Entonces la aplicación muestra más detalles del espacio deportivo</p><p>Y muestra las horas disponibles para reservar</p>|EP04|
|US13|Crear una reserva en un espacio deportivo|Como jugador quiero reservar un espacio deportivo para jugar|<p>***Escenario 1: Creación exitosa de una reserva de tipo personal***</p><p>Dado que el jugador se encuentra autenticado en la aplicación</p><p>Cuando se encuentra en la pantalla de reservas de un espacio deportivo</p><p>Y selecciona las horas de juego (recuadros verdes)</p><p>Y selecciona que la reserva sea de tipo “Personal”</p><p>Y da clic en el botón “Confirmar”</p><p>Y tiene suficientes créditos</p><p>Entonces la aplicación muestra un mensaje que la reserva se creó correctamente</p><p></p><p>***Escenario 2: Creación fallida de una reserva de tipo personal***</p><p>Dado que el jugador se encuentra autenticado en la aplicación</p><p>Cuando se encuentra en la pantalla de reservas de un espacio deportivo</p><p>Y selecciona las horas de juego (recuadros verdes)</p><p>Y selecciona que la reserva sea de tipo “Personal”</p><p>Y da clic en el botón “Confirmar”</p><p>Y no tiene suficientes créditos</p><p>Entonces la aplicación muestra un mensaje al jugador indicando que tiene insuficientes créditos</p><p></p><p>***Escenario 3: Creación exitosa de una reserva de tipo comunidad***</p><p>Dado que el jugador se encuentra autenticado en la aplicación</p><p>Cuando se encuentra en la pantalla de reservas de un espacio deportivo</p><p>Y selecciona las horas de juego (recuadros verdes)</p><p>Y selecciona que la reserva sea de tipo “Comunidad”</p><p>Y da clic en el botón “Confirmar”</p><p>Y tiene suficientes créditos para el adelanto</p><p>Entonces la aplicación muestra un mensaje que la reserva se creó correctamente</p><p>Y se crea una sala comunidad para la reserva</p><p></p><p>***Escenario 4: Creación fallida de una reserva de tipo comunidad***</p><p>Dado que el jugador se encuentra autenticado en la aplicación</p><p>Cuando se encuentra en la pantalla de reservas de un espacio deportivo</p><p>Y selecciona las horas de juego (recuadros verdes)</p><p>Y selecciona que la reserva sea de tipo “Comunidad”</p><p>Y da clic en el botón “Confirmar”</p><p>Y no tiene suficientes créditos para el adelanto</p><p>Entonces la aplicación muestra un mensaje al jugador indicando que tiene insuficientes créditos</p>|EP04|
|US14|Ver reservas realizadas|Como jugador quiero ver mis reservas realizadas para conocer su información|<p>***Escenario 1: Visualizar reservas de tipo personal***</p><p>Dado que el jugador se encuentra autenticado</p><p>Cuando da clic al botón "Mis reservas" ubicado en el toolbar</p><p>Y selecciona el tipo personal</p><p>Entonces la aplicación muestra todas las reservas realizadas de tipo personal</p><p></p><p>***Escenario 2: Visualizar reservas de tipo comunidad***</p><p>Dado que el jugador se encuentra autenticado</p><p>Cuando da clic al botón "Mis reservas" ubicado en el toolbar</p><p>Y selecciona el tipo comunidad</p><p>Entonces la aplicación muestra todas las reservas realizadas de tipo comunidad (salas)</p>|EP04|
|US15|Generar código QR de acceso al espacio deportivo|Como jugador quiero generar el código QR para acceder al espacio deportivo|<p>***Escenario 1: Generación de QR***</p><p>Dado que el jugador se encuentra autenticado</p><p>Cuando se encuentra en la pantalla de una reserva realizada</p><p>Y da clic en el botón “Generar QR de acceso”</p><p>Entonces visualizará el QR generado</p>|EP04|
|US16|Visualizar salas comunidad|Como jugador quiero visualizar las salas comunidad disponibles para unirme|<p>***Escenario 1: Visualizar salas comunidad***</p><p>Dado que el jugador se encuentra autenticado</p><p>Cuando da clic al botón "Salas comunidad" ubicado en el toolbar</p><p>Entonces la aplicación muestra todas las salas comunidad</p>|EP05|
|US17|Ingresar a una sala comunidad|Como jugador quiero ingresar a una sala comunidad para enlistarme|<p>***Escenario 1: Ingreso exitoso a la sala comunidad***</p><p>Dado que el jugador se encuentra autenticado</p><p>Cuando se encuentra en la pantalla de salas comunidad</p><p>Y da clic en el botón “Unirse” de una sala comunidad</p><p>Y tiene suficientes créditos para el adelanto</p><p>Entonces la aplicación muestra un mensaje al jugador indicando que se unió a la sala comunidad correctamente</p><p>***Escenario 2: Ingreso fallido a la sala comunidad***</p><p>Dado que el jugador se encuentra autenticado</p><p>Cuando se encuentra en la pantalla de salas comunidad</p><p>Y da clic en el botón “Unirse” de una sala comunidad</p><p>Y no tiene suficientes créditos para el adelanto</p><p>Entonces la aplicación muestra un mensaje al jugador indicando que tiene insuficientes créditos</p>|EP05|
|US18|Eliminar una sala comunidad|Como jugador creador de la reserva quiero eliminar mi sala comunidad para cancelar la reserva|<p>***Escenario 1: Eliminación exitosa de la sala comunidad***</p><p>Dado que el jugador, creador de la reserva, se encuentra autenticado</p><p>Cuando se encuentra en la pantalla de su sala comunidad seleccionada</p><p>Y da clic en el ícono “Eliminar”</p><p>Y la diferencia entre la hora actual y la hora de inicio de la sala comunidad es mayor a 1 hora</p><p>Entonces la aplicación muestra un mensaje al jugador indicando que se eliminó correctamente la sala comunidad</p><p>Y se devuelve el adelanto a cada jugador</p><p>***Escenario 2: Eliminación fallida de la sala comunidad***</p><p>Dado que el jugador, creador de la reserva, se encuentra autenticado</p><p>Cuando se encuentra en la pantalla de su sala comunidad seleccionada</p><p>Y da clic en el ícono “Eliminar”</p><p>Y la diferencia entre la hora actual y la hora de inicio de la sala comunidad es menor a 1 hora</p><p>Entonces la aplicación muestra un mensaje al jugador indicando que no es posible eliminar la sala comunidad debido a que ya falta poco tiempo para su inicio</p>|EP05|
|US19|Visualizar salas comunidad asociadas a espacios deportivos|Como propietario quiero visualizar las salas creadas a partir de mi espacio deportivo|<p>***Escenario 1: Visualizar espacios deportivos siendo propietario***</p><p>Dado que el propietario se encuentra autenticado</p><p>Cuando se encuentra en la pantalla de su espacio deportivo seleccionado</p><p>Y da clic en el botón “Ver salas creadas”</p><p>Entonces la aplicación muestra todas las salas comunidad creadas a partir de su espacio deportivo</p>|EP05|
|US20|Aplicar filtros para búsqueda de salas comunidad|Como jugador quiero aplicar filtros para encontrar salas comunidad según mis preferencias|<p>***Escenario 1: Filtrar salas comunidad según deporte***</p><p>Dado que el jugador se encuentra en la pantalla de salas comunidad</p><p>Cuando selecciona el filtro por deporte</p><p>Y selecciona “Fútbol” o “Billar”</p><p>Entonces la aplicación muestra las salas comunidad que coincidan con el deporte elegido</p><p>***Escenario 2: Filtrar salas comunidad según fecha***</p><p>Dado que el jugador se encuentra en la pantalla de salas comunidad</p><p>Cuando selecciona el filtro por fecha</p><p>Y elige una fecha específica del calendario</p><p>Entonces la aplicación muestra las salas comunidad disponibles para la fecha seleccionada</p><p>***Escenario 3: Filtrar salas comunidad según rango de horario***</p><p>Dado que el jugador se encuentra en la pantalla de salas comunidad</p><p>Cuando selecciona el filtro por rango de horario</p><p>Y elige una hora de inicio y una hora de fin</p><p>Entonces la aplicación muestra las salas comunidad que estén disponibles dentro del rango de horario seleccionado</p><p>***Escenario 4: Filtrar salas comunidad según valor del adelanto***</p><p>Dado que el jugador se encuentra en la pantalla de salas comunidad</p><p>Cuando selecciona el filtro por valor del adelanto</p><p>Y establece un rango de valores o un monto específico</p><p>Entonces la aplicación muestra las salas comunidad que coincidan con el valor del adelanto indicado</p>|EP05|
|US21|Visualizar ticket de transferencia|Como propietario quiero visualizar mis tickets de transferencia para conocer sus estados|<p>***Escenario 1: Visualizar tickets***</p><p>Dado que el propietario se encuentra autenticado</p><p>Cuando da clic al icono de perfil en la parte del toolbar</p><p>Y selecciona el apartado tickets</p><p>Entonces, la aplicación muestra la información de los tickets</p>|EP06|
|US22|Crear ticket de transferencia|Como propietario quiero crear un ticket de transferencia para recibir mi dinero|<p>***Escenario 1: Creación exitosa de ticket***</p><p>Dado que el propietario se encuentra autenticado</p><p>Cuando se encuentra en la pantalla de tickets</p><p>Y selecciona el botón “Crear ticket”</p><p>Y es lunes entre 00:00 y 06:00 horas</p><p>Y no tiene otro ticket pendiente</p><p>Y registra todos los datos solicitados en los campos: nombre completo, nombre del banco, tipo de transferencia y número de cuenta</p><p>Entonces la aplicación muestra un mensaje al propietario indicando que se creó el ticket correctamente</p><p>***Escenario 2: Creación fallida de ticket por horario***</p><p>Dado que el propietario se encuentra autenticado</p><p>Cuando se encuentra en la pantalla de tickets</p><p>Y selecciona el botón “Crear ticket”</p><p>Y no es lunes entre 00:00 y 06:00 horas</p><p>Entonces la aplicación muestra un mensaje de error, indicando la hora de disponibilidad para crear un ticket</p><p>***Escenario 3: Creación fallida de ticket por vuelta de solicitud***</p><p>Dado que el propietario se encuentra autenticado</p><p>Cuando se encuentra en la pantalla de tickets</p><p>Y selecciona el botón “Crear ticket”</p><p>Y es lunes entre 00:00 y 06:00 horas</p><p>Y tiene otro ticket pendiente</p><p>Entonces la aplicación muestra un mensaje de error, indicando que ya existe otro ticket pendiente</p>|EP06|
|US23|Recuperar contraseña|Como usuario quiero recuperar mi contraseña seguir usando mi cuenta|<p>***Escenario 1: Recuperación de contraseña exitoso***</p><p>Dado que el usuario tiene una cuenta registrada</p><p>Cuando se encuentra en la pantalla de inicio de sesión</p><p>Y da clic en el enlace de “¿Has olvidado tu contraseña?”</p><p>Y escribe su correo registrado en la aplicación</p><p>Y escribe su nueva contraseña en el formulario enviado a su correo</p><p>Entonces, su contraseña se actualiza</p>|EP01|
|US24|Conocer acerca de la aplicación|Como visitante del landing page quiero saber acerca de la aplicación para conocer sus detalles|<p>***Escenario 1: Leer acerca de la aplicación***</p><p>Dado que el visitante se encuentra en el landing page</p><p>Cuando el visitante da clic a los diferentes apartados</p><p>Entonces podrá visualizar la información deseada</p>|EP07|
|TS01|Crear usuario|Como desarrollador, necesito implementar un endpoint POST en el API nombrado "users/sign-up” para crear la información de los usuarios y registrarlos|<p>***Escenario 1: Creación de los usuarios en el API***</p><p>Dado que el desarrollador implementa un endpoint para la creación de los usuarios</p><p>Cuando solicita la creación de los usuarios con body: name, email, password y role</p><p>Entonces, es permitido de crear una cuenta a un usuario, a la par que su suscripción</p><p>***Escenario 2: Creación fallida de usuarios por existencia de email en la base de datos***</p><p>Dado que se envía una solicitud al momento de la creación del usuario</p><p>Cuando solicita la creación de los usuarios con body: name, email, password y role</p><p>Y el campo email ya existe en la base de datos</p><p>Entonces, la creación del usuario es denegada y devuelve un error 500.</p><p>***Escenario 3: Creación fallida de usuarios por no cumplir requisitos de números, uppercase y/o caracteres especiales en el campo contraseña***</p><p>Dado que se envía una solicitud al momento de la creación del usuario</p><p>Cuando solicita la creación de los usuarios con body: name, email, password y role</p><p>Y el campo contraseña no cumple los requisitos de número, uppercase y/o carácter especial</p><p>Entonces, la creación del usuario es denegada y devuelve un error 400.</p>|EP08|
|TS02|Actualizar nombre|Como desarrollador, necesito implementar un endpoint PUT en el API nombrado "users/name” para actualizar el nombre de los usuarios|<p>***Escenario 1: Actualización del nombre de los usuarios en el API***</p><p>Dado que el desarrollador implementa un endpoint para la actualización del nombre de los usuarios</p><p>Cuando solicita la petición con body: name</p><p>Entonces, es permitido de actualizar el nombre a un usuario y devuelve un code 200.</p>|EP08|
|TS03|Actualizar correo|Como desarrollador, necesito implementar un endpoint PUT en el API nombrado "users/email” para actualizar el correo de los usuarios|<p>***Escenario 1: Actualización del correo de los usuarios en el API***</p><p>Dado que el desarrollador implementa un endpoint para la actualización del correo de los usuarios</p><p>Cuando solicita la petición con body: email</p><p>Entonces, es permitido de actualizar el correo a un usuario y devuelve un code 200.</p>|EP08|
|TS04|Actualizar contraseña|Como desarrollador, necesito implementar un endpoint PUT en el API nombrado "users/password” para actualizar la contraseña de los usuarios|<p>***Escenario 1: Actualización de la contraseña de los usuarios en el API***</p><p>Dado que el desarrollador implementa un endpoint para la actualización de la contraseña de los usuarios</p><p>Cuando solicita la petición con body: password</p><p>Entonces, es permitido de actualizar la contraseña a un usuario y devuelve un code 200.</p><p>***Escenario 2: Actualización fallida de contraseña de usuarios por no cumplir requisitos de números, uppercase y/o caracteres especiales en el campo contraseña***</p><p>Dado que se envía una solicitud al momento de la actualización del usuario</p><p>Cuando solicita la petición con body: password</p><p>Y el campo contraseña no cumple los requisitos de número, uppercase y/o carácter especial</p><p>Entonces, la actualización de la contraseña es denegada y devuelve un error 400.</p>|EP08|
|TS05|Obtener todos los usuarios|Como desarrollador, necesito implementar un endpoint GET en el API nombrado "users/all” para obtener todos los usuarios|<p>***Escenario 1: Obtención de todos los usuarios en el API***</p><p>Dado que el desarrollador implementa un endpoint para la obtención de todos los usuarios</p><p>Cuando solicita la petición sin body ni params</p><p>Y su rol es ADMIN</p><p>Entonces, es permitido de obtener todos los usuarios y devuelve un code 200.</p><p>***Escenario 2: Obtención fallida de todos los usuarios por tener rol PLAYER u OWNER***</p><p>Dado que se envía una solicitud al momento de la obtención de todos los usuarios</p><p>Cuando solicita la petición sin body ni params</p><p>Y el usuario tiene rol PLAYER u OWNER</p><p>Entonces, la obtención de todos los usuarios es denegada y devuelve un error 500.</p>|EP08|
|TS06|Obtener información del usuario|Como desarrollador, necesito implementar un endpoint GET en el API nombrado "users/me” para que, al consultar mediante un usuario específico, me obtenga su información|<p>***Escenario 1: Obtención de información de un usuario específico en el API***</p><p>Dado que el desarrollador implementa un endpoint para la obtención de información de un usuario específico</p><p>Cuando solicita la petición sin body ni params</p><p>Y está autenticado mediante la cookie</p><p>Entonces, es permitido de obtener la información del usuario y devuelve un code 200.</p><p>***Escenario 2: Obtención fallida de información de un usuario específico por no estar autenticado***</p><p>Dado que se envía una solicitud al momento de la obtención de información de un usuario específico</p><p>Cuando solicita la petición</p><p>Y no está autenticado</p><p>Entonces, la obtención de la información del usuario será denegada y devuelve un error 500.</p>|EP08|
|TS07|Autenticar usuario|Como desarrollador, necesito implementar un endpoint POST en el API nombrado "authentication/sign-in” para poder autenticarme y luego brindarme permisos|<p>***Escenario 1: Autenticación y autorización de un usuario***</p><p>Dado que el desarrollador implementa un endpoint para la autenticación y autorización un usuario</p><p>Cuando solicita la petición con body: email y password</p><p>Entonces, es permitido de autenticarse y autorizar al usuario y devuelve un code 200.</p><p>***Escenario 2: Autenticación y/o autorización fallida de un usuario por contraseña errónea***</p><p>Dado que se envía una solicitud al momento de la autenticación del usuario</p><p>Cuando solicita la petición con body: email y password</p><p>Y su contraseña está errónea</p><p>Entonces, es denegada el autenticar y autorizar al usuario</p><p>***Escenario 3: Autenticación y/o autorización fallida de un usuario por correo erróneo***</p><p>Dado que se envía una solicitud al momento de la autenticación del usuario</p><p>Cuando solicita la petición con body: email y password</p><p>Y su correo está erróneo</p><p>Entonces, es denegada, el autenticar y autorizar al usuario y devuelve un error 500.</p>|EP09|
|TS08|Desautenticar usuario|Como desarrollador, necesito implementar un endpoint POST en el API nombrado "authentication/log-out” para poder desautenticarme de la sesión|<p>***Escenario 1: Desautenticación y desautorización de un usuario***</p><p>Dado que el desarrollador implementa un endpoint para la desautenticación y desautorización un usuario</p><p>Cuando solicita la petición sin body ni params</p><p>Entonces, es permitido de desautenticarse y desautorizar al usuario en la sesión y devuelve un code 200.</p>|EP09|
|TS09|Verificar autenticación|Como desarrollador, necesito implementar un endpoint GET en el API nombrado "authentication/is-authenticated” para poder obtener si estoy autenticado o no|<p>***Escenario 1: Obtención de la autenticación del usuario en tiempo real***</p><p>Dado que el desarrollador implementa un endpoint para la obtención de la autenticación del usuario</p><p>Cuando solicita la petición sin body ni params</p><p>Entonces, es permitido de visualizar si está autenticado o no y devuelve un code 200.</p>|EP09|
|TS10|Actualizar suscripción|Como desarrollador, necesito implementar un endpoint PUT en el API nombrado "subscriptions/upgrade” para poder actualizar mi suscripción|<p>***Escenario 1: Actualización de la suscripción de un usuario***</p><p>Dado que el desarrollador implementa un endpoint para la actualización de una suscripción de un usuario</p><p>Cuando solicita la petición con params: newPlanType</p><p>Y elige uno de los 3 planes posibles: bronce, plata u oro</p><p>Y lo redirige a una API externa, via Paypal</p><p>Y le pide sus datos para continuar con el pago</p><p>Y el usuario paga con su cuenta de PayPal</p><p>Entonces, es permitido la actualización de suscripción del usuario y devuelve un code 200.</p><p>***Escenario 2: Actualización fallida por insuficiente dinero en cuenta de PayPal***</p><p>Dado que se envía una solicitud de actualización de suscripción de usuario</p><p>Cuando solicita la petición con params: newPlanType</p><p>Y elige uno de los 3 planes posibles: bronce, plata u oro</p><p>Y lo redirige a una API externa, via Paypal</p><p>Y le pide sus datos para continuar con el pago</p><p>Y el usuario intenta pagar con su cuenta de PayPal</p><p>Y su cuenta de Paypal no tiene fondos suficientes</p><p>Entonces es denegada, la actualización de suscripción del usuario y devuelve un error 500.</p><p>***Escenario 3: Actualización fallida por intento de degradar la suscripción***</p><p>Dado que se envía una solicitud de intento de degradación de suscripción de un usuario</p><p>Cuando solicita la petición con params: newPlanType</p><p>Y elige uno de los 3 planes posibles: bronce, plata u oro</p><p>Y se verifica la solicitud de envío</p><p>Entonces, es denegada la degradación de la suscripción del usuario y devuelve un error 500.</p>|EP10|
|TS11|Obtener suscripción de un usuario específico|Como desarrollador, necesito implementar un endpoint GET en el API nombrado "api/v1/subscriptions” para que los usuarios obtengan los datos de su suscripción|<p>***Escenario 1: Obtención de la suscripción de un usuario específico***</p><p>Dado que el desarrollador implementa un endpoint para la obtención de la suscripción de un usuario específico</p><p>Cuando solicita la petición sin body ni params</p><p>Entonces es permitido, la visualización de la suscripción de un usuario específico y devuelve un code 200.</p>|EP10|
|TS12|Crear espacio deportivo|Como desarrollador, necesito implementar un endpoint POST en el API nombrado "sport-spaces/create” para que los usuarios con rol OWNER, puedan crear sus espacios deportivos|<p>***Escenario 1: Creación correcta del espacio deportivo***</p><p>Dado que se envía una solicitud de creación de espacio deportivo</p><p>Cuando solicita la petición con body multipart/form-data: name, sportId, image, Price, district, address, description, openTime, closeTime, gamemode</p><p>Y el usuario tiene rol OWNER</p><p>Y tiene una suscripción diferente a FREE</p><p>Y el horario corresponde a un intervalo entre las 00:00 y las 06:00 horas de los lunes</p><p>Entonces, se crea y devuelve un code 200.</p><p>***Escenario 2: Creación fallida por restricción horaria***</p><p>Dado que se envía una solicitud de creación de espacio deportivo</p><p>Cuando solicita la petición con body multipart/form-data: name, sportId, image, Price, district, address, description, openTime, closeTime, gamemode</p><p>Y el usuario tiene rol OWNER</p><p>Y tiene una suscripción diferente a FREE</p><p>Y el horario no corresponde a un intervalo entre las 00:00 y las 06:00 horas de los lunes</p><p>Entonces, es denegada la creación y te devuelve un error 500.</p>|EP11|
|TS13|Obtener espacio deportivo por ID|Como desarrollador, necesito implementar un endpoint GET en el API nombrado "sport-spaces/{id}” para que los usuarios PLAYER puedan obtener espacios deportivos por ID|<p>***Escenario 1: Obtención de un espacio deportivo por ID, según rol PLAYER***</p><p>Dado que el desarrollador implementa un endpoint para la obtención de espacios deportivos según ID</p><p>Cuando solicita la petición con params: id</p><p>Y el usuario tiene rol PLAYER</p><p>Y está autenticado y autorizado</p><p>Entonces, es permitido la obtención de los espacios deportivos por ID y devuelve un code 200.</p>|EP11|
|TS14|Obtener espacio deportivo de un usuario específico|Como desarrollador, necesito implementar un endpoint GET en el API nombrado "sport-spaces/my-space” para que los usuarios con rol OWNER puedan consultar sus espacios deportivos|<p>***Escenario 1: Obtención de un espacio deportivo según rol OWNER***</p><p>Dado que el desarrollador implementa un endpoint para la obtención de los espacios deportivos propios</p><p>Cuando solicita la petición sin body ni params</p><p>Y el usuario tiene rol OWNER</p><p>Y está autenticado y autorizado</p><p>Entonces, es permitido la obtención de los espacios deportivos correspondientes de ese usuario y devuelve un code 200.</p>|EP11|
|TS15|Obtener todos los espacios deportivos|Como desarrollador, necesito implementar un endpoint GET en el API nombrado "sport-spaces/all” para obtener todos los espacios deportivos existentes|<p>***Escenario 1: Obtención de todos los espacios deportivos según rol ADMIN o PLAYER***</p><p>Dado que el desarrollador implementa un endpoint para la obtención de todos los espacios deportivos</p><p>Cuando solicita la petición sin body ni params</p><p>Y el usuario tiene rol ADMIN o PLAYER</p><p>Entonces, es permitido la obtención de todos los espacios deportivos y devuelve un code 200.</p>|EP11|
|TS16|Eliminar un espacio deportivo|Como desarrollador, necesito implementar un endpoint DELETE en el API nombrado "sport-spaces/{id}” para que un usuario OWNER pueda eliminar su espacio deportivo|<p>***Escenario 1: Eliminación de un espacio deportivo de un usuario OWNER***</p><p>Dado que el desarrollador implementa un endpoint para la eliminación de un espacio deportivo</p><p>Cuando solicita la petición con params: id</p><p>Y el usuario tiene rol OWNER</p><p>Entonces, es permitido la eliminación ese espacio deportivo y devuelve un code 200.</p><p>***Escenario 2: Eliminación fallida por restricción horaria y de día***</p><p>Dado que se envía una solicitud para la eliminación de un espacio deportivo</p><p>Cuando solicita la petición</p><p>Y el usuario tiene rol OWNER</p><p>Y el horario no corresponde a un intervalo entre las 00:00 y las 06:00 horas de los lunes</p><p>Entonces, es denegada la eliminación de ese espacio deportivo y devuelve un error 500.</p>|EP11|
|TS17|Crear una reserva|Como desarrollador, necesito implementar un endpoint POST en el API nombrado "reservations/create" para que un usuario PLAYER pueda realizar una reserva|<p>***Escenario 1: Creación de una reserva de un usuario PLAYER***</p><p>Dado que el desarrollador implementa un endpoint para la creación de una reserva</p><p>Cuando solicita la petición con body: gameDay, startTime, endTime, sportSpacesId, type, reservationName</p><p>Y el usuario tiene rol PLAYER</p><p>Entonces, es permitido la creación de esa reserva y devuelve un code 200.</p><p>***Escenario 2: Creación fallida por no cumplimiento de intervalo de horas de acuerdo con el espacio deportivo***</p><p>Dado que se envía una solicitud para la creación de un espacio deportivo</p><p>Cuando solicita la petición</p><p>Y el usuario tiene rol PLAYER</p><p>Y el horario, en el cual se reserva, está fuera del rango, en el cual, el espacio deportivo abre</p><p>Entonces, es denegada la creación de esa reserva y devuelve un error 500.</p><p>***Escenario 3: Creación fallida por no cumplimiento de intervalo de fechas en solo la semana actual***</p><p>Dado que se envía una solicitud para la creación de un espacio deportivo</p><p>Cuando solicita la petición</p><p>Y el usuario tiene rol PLAYER</p><p>Y la fecha, en la cual se reserva, está fuera del rango de la semana actual</p><p>Entonces, es denegada la creación de esa reserva y devuelve un error 500.</p><p>***Escenario 4: Creación fallida por cantidad de créditos insuficientes***</p><p>Dado que se envía una solicitud para la creación de un espacio deportivo</p><p>Cuando solicita la petición</p><p>Y el usuario tiene rol PLAYER</p><p>Y la cantidad de créditos del usuario no cubre el monto solicitado de la reserva</p><p>Entonces, es denegada la creación de esa reserva y devuelve un error 500.</p>|EP12|
|TS18|Obtener una reserva|Como desarrollador, necesito implementar un endpoint GET en el API nombrado "reservations/my-reservations" para que un usuario PLAYER pueda visualizar sus reservas|<p>***Escenario 1: Obtención de una reserva de un usuario PLAYER***</p><p>Dado que el desarrollador implementa un endpoint para la obtención de una reserva</p><p>Cuando solicita la petición sin body ni params</p><p>Y el usuario tiene rol PLAYER</p><p>Entonces, es permitido la obtención de sus reservas y devuelve un code 200.</p>|EP12|
|TS19|Eliminar una reserva|Como desarrollador, necesito implementar un endpoint DELETE en el API nombrado "reservations/{id}" para que un usuario PLAYER pueda eliminar sus reservas|<p>***Escenario 1: Eliminación de una reserva de un usuario PLAYER***</p><p>Dado que el desarrollador implementa un endpoint para la eliminación de una de sus reservas</p><p>Cuando solicita la petición con params: id</p><p>Y el usuario tiene rol PLAYER</p><p>Y el tipo de la reserva es COMMUNITY</p><p>Y la sala no está llena</p><p>Entonces, es permitido la eliminación de la reserva específica y devuelve un code 200.</p><p>***Escenario 2: Eliminación fallida por restricción de horario y día de semana***</p><p>Dado que se envía una solicitud para la eliminación de una de sus reservas</p><p>Cuando solicita la petición con params: id</p><p>Y el usuario tiene rol PLAYER</p><p>Y el tipo de la reserva es COMMUNITY</p><p>Y la sala no está llena</p><p>Y el día de la eliminación no es lunes, ni está en el intervalo de 00:00 a 06:00</p><p>Entonces, es denegada la eliminación de la reserva específica y devuelve un error 500.</p>|EP12|
|TS20|Obtener y verificar un Qr|Como desarrollador, necesito implementar un endpoint GET en el API nombrado "reservations/verify-qr-image” para que un usuario PLAYER pueda obtener sus QR para ingresar al espacio deportivo|<p>***Escenario 1: Obtención de QR para acceder al espacio deportivo***</p><p>Dado que el desarrollador implementa un endpoint para la obtención del QR para acceder a los espacios deportivos reservados por un usuario</p><p>Cuando solicita la petición con params: token</p><p>Y el usuario tiene rol PLAYER</p><p>Entonces, es permitido la obtención del QR para acceder al espacio deportivo de acuerdo con la reserva del usuario y devuelve un code 200</p>|EP12|
|TS21|Usar Qr|Como desarrollador, necesito implementar un endpoint POST en el API nombrado "reservations/user-qr-token” para que un usuario PLAYER pueda usar sus QR para ingresar al espacio deportivo|<p>***Escenario 1: Usar el QR al acceder al espacio deportivo***</p><p>Dado que el desarrollador implementa un endpoint para el uso del QR al acceder a los espacios deportivos reservados por un usuario</p><p>Cuando solicita la petición con params: token</p><p>Y el usuario tiene rol PLAYER</p><p>Entonces, es permitido el uso del QR para acceder al espacio deportivo de acuerdo con la reserva del usuario y devuelve un code 200</p><br><p>***Escenario 2: Escaneo de Qr fallido por uso ya existente***</p><p>Dado que el desarrollador implementa un endpoint para el uso del QR al acceder a los espacios deportivos reservados por un usuario</p><p>Cuando solicita la petición con params: token</p><p>Y el usuario tiene rol PLAYER</p><p>Y el QR ya ha sido usado</p><p>Entonces, es denegado el uso del QR para acceder al espacio deportivo de acuerdo con la reserva del usuario y devuelve un error 500</p><br><p>***Escenario 3: Escaneo de Qr fallido por token expirado***</p><p>Dado que el desarrollador implementa un endpoint para el uso del QR al acceder a los espacios deportivos reservados por un usuario</p><p>Cuando solicita la petición con params: token</p><p>Y el usuario tiene rol PLAYER</p><p>Y ha expirado el token del QR para poder usarlo, de acuerdo con las fechas establecidas de uso en el intervalo del horario de la reserva</p><p>Entonces, es denegado el uso del QR para acceder al espacio deportivo de acuerdo con la reserva del usuario y devuelve un error 500</p>|EP12|
|TS22|Unirse a una room|Como desarrollador, necesito implementar un endpoint POST en el API nombrado "player-lists/join” para que un usuario PLAYER pueda unirse a una reserva de tipo COMMUNITY creada por otro usuario PLAYER|<p>***Escenario 1: Unirse a una reserva de tipo COMMUNITY***</p><p>Dado que el desarrollador implementa un endpoint para que un usuario se pueda unir a una reserva tipo COMMUNITY</p><p>Cuando solicita la petición con params: roomId</p><p>Y el usuario tiene rol PLAYER</p><p>Y el usuario tiene créditos suficientes para cubrir el monto del adelanto</p><p>Entonces, es permitido el poder unirse a una reserva de tipo COMMUNITY y devuelve un code 200</p><br><p>***Escenario 2: Integración a una sala fallida por cantidad de créditos insuficientes***</p><p>Dado que se envía una solicitud para la integración a una sala</p><p>Cuando solicita la petición con params: roomId</p><p>Y el usuario tiene rol PLAYER</p><p>Y la cantidad de créditos del usuario no cubre el monto solicitado de la reserva</p><p>Entonces, es denegada la integración a esa sala y devuelve un error 500</p>|EP13|
|TS23|Obtener la lista de jugadores de una sala|Como desarrollador, necesito implementar un endpoint GET en el API nombrado "player-lists/room/{roomId}” para que obtener a los usuarios que están en una sala|<p>***Escenario 1: Obtener la lista de jugadores de una sala***</p><p>Dado que el desarrollador implementa un endpoint para que obtener la lista de jugadores de una sala</p><p>Cuando solicita la petición con params: roomId</p><p>Entonces, es permitido el poder obtener la lista de jugadores y devuelve un code 200</p>|EP13|
|TS24|Crear un chat en base a una sala|Como desarrollador, necesito implementar un endpoint POST en el API nombrado "chat/rooms/{chatRoomId}/messages” para que crear un chat en base a una sala creada|<p>***Escenario 1: Creación de mensajes en un chat de sala***</p><p>Dado que el desarrollador implementa un endpoint para enviar mensajes en un chat de una sala</p><p>Cuando solicita la petición con params: chatRoomId</p><p>Entonces, es permitido el poder enviar un mensaje al chat y devuelve un code 200</p>|EP14|
|TS25|Crear un depósito|Como desarrollador, necesito implementar un endpoint POST en el API nombrado "deposit/create-deposit” para que se realice un depósito como usuario PLAYER|<p>***Escenario 1: Creación de un depósito***</p><p>Dado que el desarrollador implementa un endpoint para la creación de un depósito</p><p>Cuando solicita la petición con params: amount</p><p>Y lo redirige a una API externa, vía PayPal</p><p>Y le pide sus datos para continuar con el pago</p><p>Y el usuario paga con su cuenta de PayPal</p><p>Entonces, es permitida la creación del depósito y devuelve un code 200.</p><br><p>***Escenario 2: Creación fallida por insuficiente dinero en cuenta de PayPal***</p><p>Dado que se envía una solicitud de creación de depósito</p><p>Cuando solicita la petición con params: amount</p><p>Y lo redirige a una API externa, vía PayPal</p><p>Y le pide sus datos para continuar con el pago</p><p>Y el usuario intenta pagar con su cuenta de PayPal</p><p>Y su cuenta de PayPal no tiene fondos suficientes</p><p>Entonces, es denegada la creación de depósito y devuelve un error 500.</p>|EP15|
|TS26|Crear una petición para retiro|Como desarrollador, necesito implementar un endpoint POST en el API nombrado "bank-transfer/create” para que se realice una petición de retiro de créditos como usuario OWNER|<p>***Escenario 1: Creación de una petición de retiro***</p><p>Dado que el desarrollador implementa un endpoint para la creación de una petición de retiro de un usuario OWNER</p><p>Cuando solicita la petición con body: fullName, bankName, transferType y accountNumber</p><p>Y el usuario tiene créditos por cobrar</p><p>Entonces, es permitida la creación de la petición para retiro y devuelve un code 200.</p><br><p>***Escenario 2: Creación fallida por tener una petición activa***</p><p>Dado que el desarrollador implementa un endpoint para la creación de una petición de retiro de un usuario OWNER</p><p>Cuando solicita la petición con body: fullName, bankName, transferType y accountNumber</p><p>Y el usuario ya realizó una petición de retiro</p><p>Entonces, es denegada la creación de la petición para retiro y devuelve un error 500.</p>|EP16|
|TS27|Atender la solicitud de retiro de un usuario OWNER|Como desarrollador, necesito implementar un endpoint PATCH en el API nombrado "bank-transfer/update-transfer/{id}” para que se atienda una petición de retiro de créditos como usuario ADMIN|<p>***Escenario 1: Atender la petición de retiro de un usuario OWNER***</p><p>Dado que el desarrollador implementa un endpoint para atender una petición de retiro de un usuario OWNER siendo usuario ADMIN</p><p>Cuando solicita la petición con params: id</p><p>Y la petición del usuario OWNER tiene créditos por cobrar</p><p>Entonces, es permitido la creación de la petición para atender el retiro y se le reduce la cantidad de créditos del usuario que solicitó la solicitud a 0 y devuelve un code 200.</p>|EP16|
|TS28|Obtener la solicitud de retiro de un usuario OWNER|Como desarrollador, necesito implementar un endpoint GET en el API nombrado "bank-transfer/user/{userId}” para que se obtenga la petición propia de retiro de créditos de un usuario específico como usuario OWNER y de todos, de acuerdo con el userId, según usuario ADMIN|<p>***Escenario 1: Obtener la petición de retiro de un usuario OWNER propia***</p><p>Dado que el desarrollador implementa un endpoint para obtener una petición de retiro de un usuario OWNER</p><p>Cuando solicita la petición con params: userId</p><p>Y el usuario tiene rol OWNER o ADMIN</p><p>Entonces, es permitido la obtención de la petición de retiro y devuelve un code 200.</p>|EP16|
|TS29|Obtener la solicitud de todos los retiros de todos los usuarios OWNER|Como desarrollador, necesito implementar un endpoint GET en el API nombrado "bank-transfer/all” para que se obtenga los retiros de créditos de todos los usuarios OWNER con usuario ADMIN|<p>***Escenario 1: Obtener todas las peticiones de retiro de todos los usuarios OWNER***</p><p>Dado que el desarrollador implementa un endpoint para obtener todas las peticiones de retiro de créditos de todos los usuarios OWNER</p><p>Cuando solicita la petición sin body ni params</p><p>Y el usuario tiene rol ADMIN</p><p>Entonces, es permitido la obtención de todas las peticiones de retiro y devuelve un code 200.</p>|EP16|
|TS30|Obtener las salas por ID|Como desarrollador, necesito implementar un endpoint GET en el API nombrado "rooms/{id}” para que se obtenga las salas en base a su id|<p>***Escenario 1: Obtener las salas en base a su id***</p><p>Dado que el desarrollador implementa un endpoint para obtener las salas en base a su id</p><p>Cuando solicita la petición con params: id</p><p>Entonces, es permitido la obtención de las salas en base a su id con un code 200.</p>|EP17|
|TS31|Obtener las salas por usuario específico|Como desarrollador, necesito implementar un endpoint GET en el API nombrado "rooms/my-rooms” para que se obtenga las salas reservadas del propio usuario|<p>***Escenario 1: Obtener las salas de un usuario específico***</p><p>Dado que el desarrollador implementa un endpoint para obtener las salas en base a un usuario específico</p><p>Cuando solicita la petición sin body ni params</p><p>Y el usuario tiene salas reservadas</p><p>Entonces, es permitido la obtención de las salas en base a su id con un code 200.</p>|EP17|
|TS32|Obtener las salas en base a los espacios deportivos|Como desarrollador, necesito implementar un endpoint GET en el API nombrado "rooms/my-rooms-by-spaces” para que se obtenga las salas reservadas de un espacio deportivo de acuerdo con un usuario OWNER|<p>***Escenario 1: Obtener las salas en base a un espacio deportivo de acuerdo con un usuario OWNER***</p><p>Dado que el desarrollador implementa un endpoint para obtener las salas en base a un espacio deportivo de acuerdo con un usuario OWNER</p><p>Cuando solicita la petición sin body ni params</p><p>Y el usuario tiene espacios deportivos con salas vinculadas por usuarios PLAYER</p><p>Entonces, es permitido la obtención de sus salas en base a sus espacios deportivos con un code 200.</p>|EP17|
|TS33|Obtener salas en base a jugador específico unido|Como desarrollador, necesito implementar un endpoint GET en el API nombrado "rooms/my-join-rooms” para que se obtenga las salas que un usuario específico se haya unido|<p>***Escenario 1: Obtener salas en base a un jugador específico que se haya unido***</p><p>Dado que el desarrollador implementa un endpoint para obtener las salas en donde un usuario específico se ha unido</p><p>Cuando solicita la petición sin body ni params</p><p>Y el usuario tiene salas a las cuales se ha unido</p><p>Entonces, es permitido la obtención de sus salas a las cuales se ha unido con un code 200.</p>|EP17|
|TS34|Obtener todas las salas|Como desarrollador, necesito implementar un endpoint GET en el API nombrado "rooms/all” para que se obtenga todas las salas siendo usuario ADMIN|<p>***Escenario 1: Obtener todas las salas siendo usuario ADMIN***</p><p>Dado que el desarrollador implementa un endpoint para obtener todas las salas</p><p>Cuando solicita la petición sin body ni params</p><p>Y el usuario tiene rol ADMIN</p><p>Entonces, es permitido la obtención de todas las salas con un code 200.</p>|EP17|
|TS35|Solicitar olvido de contraseña|Como desarrollador, necesito implementar un endpoint POST en el API nombrado "recover-password/forgot-password” para que se solicite un enlace para recuperar contraseña|<p>***Escenario 1: Solicitud de mandado de enlace a email ingresado exitoso***</p><p>Dado que el desarrollador implementa un endpoint para solicitar un enlace para recuperar contraseña</p><p>Cuando solicita la petición con params: email</p><p>Y el usuario tiene un email registrado en la base de datos</p><p>Entonces, es permitido el envío de su recuperación de contraseña a su correo con un code 200.</p>|EP08|
|TS36|Reiniciar contraseña|Como desarrollador, necesito implementar un endpoint POST en el API nombrado "recover-password/reset-password” para que se reinicie contraseña|<p>***Escenario 1: Reinicio exitoso de contraseña***</p><p>Dado que el desarrollador implementa un endpoint para reiniciar la contraseña</p><p>Cuando solicita la petición con body: token y newPassword</p><p>Y el campo newPassword cumple los requisitos de número, uppercase y/o carácter especial</p><p>Entonces, es permitido el reinicio de su contraseña con un code 200.</p>|EP08|


## 3.3. Impact Mapping

<img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//impact-mapping.png" alt="UPC">

## 3.4. Product Backlog

| #Orden | User Story ID | Título                                     | Descripción                                                                                         | Story Points |
|--------|---------------|--------------------------------------------|-----------------------------------------------------------------------------------------------------|--------------|
| 1      | TS17          | Crear una reserva                          | Como desarrollador deseo implementar el endpoint `POST reservations/create` para que un usuario PLAYER realice una reserva | 8 |
| 2      | TS01          | Crear usuario                              | Como desarrollador deseo implementar el endpoint `POST users/sign-up` para registrar usuarios en la app | 5 |
| 3      | TS10          | Actualizar suscripción                     | Como desarrollador deseo implementar el endpoint `PUT subscriptions/upgrade` para actualizar la suscripción de un usuario | 5 |
| 4      | TS25          | Crear un depósito                          | Como desarrollador deseo implementar el endpoint `POST deposit/create-deposit` para que un jugador recargue créditos | 5 |
| 5      | TS22          | Unirse a una room                          | Como desarrollador deseo implementar el endpoint `POST player-lists/join` para que un usuario se una a una sala COMMUNITY | 5 |
| 6      | TS26          | Crear petición para retiro                 | Como desarrollador deseo implementar el endpoint `POST bank-transfer/create` para solicitar retiro de créditos como OWNER | 5 |
| 7      | TS27          | Atender solicitud de retiro                | Como desarrollador deseo implementar el endpoint `PATCH bank-transfer/update-transfer/{id}` para que un ADMIN atienda la solicitud | 5 |
| 8      | TS29          | Obtener todas solicitudes de retiro        | Como desarrollador deseo implementar el endpoint `GET bank-transfer/all` para obtener todas las solicitudes de retiro | 2 |
| 9      | TS21          | Usar QR                                    | Como desarrollador deseo implementar el endpoint `POST reservations/user-qr-token` para que el jugador use su QR | 5 |
| 10     | TS20          | Obtener y verificar un QR                  | Como desarrollador deseo implementar el endpoint `GET reservations/verify-qr-image` para obtener el QR de acceso | 5 |
| 11     | TS07          | Autenticar usuario                         | Como desarrollador deseo implementar el endpoint `POST authentication/sign-in` para autenticar a un usuario | 5 |
| 12     | TS04          | Actualizar contraseña                      | Como desarrollador deseo implementar el endpoint `PUT users/password` para actualizar la contraseña del usuario | 2 |
| 13     | TS02          | Actualizar nombre                          | Como desarrollador deseo implementar el endpoint `PUT users/name` para actualizar el nombre del usuario | 2 |
| 14     | TS03          | Actualizar correo                          | Como desarrollador deseo implementar el endpoint `PUT users/email` para actualizar el correo del usuario | 2 |
| 15     | TS08          | Desautenticar usuario                      | Como desarrollador deseo implementar el endpoint `POST authentication/log-out` para cerrar sesión del usuario | 2 |
| 16     | TS28          | Obtener solicitud de retiro de un usuario | Como desarrollador deseo implementar el endpoint `GET bank-transfer/user/{userId}` para obtener la solicitud de retiro de un usuario | 2 |
| 17     | TS23          | Obtener lista de jugadores de una sala    | Como desarrollador deseo implementar el endpoint `GET player-lists/room/{roomId}` para ver jugadores de una sala | 3 |
| 18     | TS24          | Crear un chat en base a una sala           | Como desarrollador deseo implementar el endpoint `POST chat/rooms/{chatRoomId}/messages` para crear un chat en una sala | 3 |
| 19     | TS11          | Obtener suscripción de un usuario          | Como desarrollador deseo implementar el endpoint `GET api/v1/subscriptions` para ver la suscripción de un usuario | 2 |
| 20     | TS13          | Obtener espacio deportivo por ID           | Como desarrollador deseo implementar el endpoint `GET sport-spaces/{id}` para obtener un espacio deportivo por ID | 2 |
| 21     | TS14          | Obtener espacios propios                   | Como desarrollador deseo implementar el endpoint `GET sport-spaces/my-space` para que un OWNER vea sus espacios | 2 |
| 22     | TS12          | Crear espacio deportivo                    | Como desarrollador deseo implementar el endpoint `POST sport-spaces/create` para que un OWNER cree un espacio deportivo | 5 |
| 23     | TS15          | Obtener todos los espacios deportivos      | Como desarrollador deseo implementar el endpoint `GET sport-spaces/all` para obtener todos los espacios deportivos | 2 |
| 24     | TS16          | Eliminar un espacio deportivo              | Como desarrollador deseo implementar el endpoint `DELETE sport-spaces/{id}` para eliminar un espacio como OWNER | 5 |
| 25     | TS06          | Obtener información del usuario            | Como desarrollador deseo implementar el endpoint `GET users/me` para obtener la información del usuario autenticado | 2 |
| 26     | TS05          | Obtener todos los usuarios                 | Como desarrollador deseo implementar el endpoint `GET users/all` para que un ADMIN obtenga todos los usuarios | 2 |
| 27     | TS18          | Obtener reservas                           | Como desarrollador deseo implementar el endpoint `GET reservations/my-reservations` para ver reservas del usuario | 2 |
| 28     | TS19          | Eliminar una reserva                       | Como desarrollador deseo implementar el endpoint `DELETE reservations/{id}` para eliminar una reserva como PLAYER | 5 |
| 29     | TS30          | Obtener sala por ID                        | Como desarrollador deseo implementar el endpoint `GET rooms/{id}` para obtener una sala por su ID  | 2 |
| 30     | TS31          | Obtener salas por usuario específico       | Como desarrollador deseo implementar el endpoint `GET rooms/my-rooms` para obtener salas propias   | 2 |
| 31     | TS32          | Obtener salas por espacios deportivos      | Como desarrollador deseo implementar el endpoint `GET rooms/my-rooms-by-spaces` para ver salas por espacio | 2 |
| 32     | TS33          | Obtener salas unidas por jugador           | Como desarrollador deseo implementar el endpoint `GET rooms/my-join-rooms` para ver salas unidas   | 2 |
| 33     | TS34          | Obtener todas las salas (ADMIN)            | Como desarrollador deseo implementar el endpoint `GET rooms/all` para obtener todas las salas como ADMIN | 2 |
| 34     | TS35          | Solicitar olvido de contraseña             | Como desarrollador deseo implementar el endpoint `POST recover-password/forgot-password` para solicitar recuperación | 3 |
| 35     | TS36          | Reiniciar contraseña                       | Como desarrollador deseo implementar el endpoint `POST recover-password/reset-password` para reiniciar la contraseña | 3 |
| 36     | TS09          | Verificar autenticación                    | Como desarrollador deseo implementar el endpoint `GET authentication/is-authenticated` para verificar si estoy autenticado | 2 |
| 37      | US01          | Registro de cuenta de usuario              | Como jugador o propietario deseo registrarme para tener una cuenta en D’Taquito                    | 2            |
| 38      | US02          | Inicio de sesión de cuenta                 | Como jugador o propietario deseo ingresar a mi cuenta para usar funcionalidades de la app          | 2            |
| 39      | US03          | Ver perfil de usuario                      | Como jugador o propietario deseo acceder a mi perfil para visualizar mis datos personales          | 2            |
| 40      | US04          | Editar perfil de usuario                   | Como usuario deseo editar mis datos personales para mantener mi perfil actualizado                 | 2            |
| 41      | US05          | Recargar crédito                           | Como jugador deseo recargar crédito para reservar un espacio deportivo                             | 3            |
| 42      | US06          | Ver una suscripción                        | Como propietario deseo ver el estado de mi suscripción para gestionarla                            | 3            |
| 43      | US07          | Actualizar una suscripción                 | Como usuario propietario deseo actualizar mi suscripción para usar los beneficios que me da        | 3            |
| 44      | US08          | Visualizar espacios deportivos             | Como jugador o propietario deseo ver los espacios deportivos para conocer sus detalles             | 2            |
| 45      | US09          | Añadir un espacio deportivo                | Como propietario deseo añadir mi espacio deportivo para que los jugadores puedan visualizarlo      | 2            |
| 46     | US12          | Visualizar horas disponibles               | Como jugador deseo visualizar las horas disponibles de un espacio deportivo para reservar          | 2            |
| 47     | US13          | Crear una reserva en un espacio deportivo | Como jugador deseo reservar un espacio deportivo para jugar para asegurar mi tiempo de juego       | 5            |
| 48     | US14          | Ver reservas realizadas                    | Como jugador deseo ver mis reservas realizadas para conocer su información                         | 2            |
| 49     | US16          | Visualizar salas comunidad                 | Como jugador deseo visualizar las salas comunidad disponibles para unirme                          | 2            |
| 50     | US17          | Ingresar a una sala comunidad              | Como jugador deseo ingresar a una sala comunidad para enlistarme                                   | 5            |
| 51     | US18          | Eliminar una sala comunidad                | Como creador de la reserva deseo eliminar mi sala comunidad para cancelar la reserva               | 3            |
| 52     | US10          | Eliminar un espacio deportivo              | Como propietario deseo eliminar mi espacio deportivo porque ya no quiero que esté registrado       | 2            |
| 53     | US22          | Crear ticket de transferencia              | Como propietario deseo crear un ticket de transferencia para recibir mi dinero                     | 3            |
| 54     | US21          | Visualizar ticket de transferencia         | Como propietario deseo visualizar mis tickets de transferencia para conocer sus estados            | 2            |
| 55     | US15          | Generar código QR de acceso                | Como jugador deseo generar el código QR para acceder al espacio deportivo                          | 2            |
| 56     | US19          | Visualizar salas asociadas a mis espacios | Como propietario deseo visualizar las salas creadas a partir de mi espacio deportivo               | 2            |
| 57     | US20          | Aplicar filtros a salas comunidad          | Como jugador deseo aplicar filtros para encontrar salas comunidad según mis preferencias           | 2            |
| 58     | US11          | Aplicar filtros a espacios deportivos      | Como jugador deseo aplicar filtros para encontrar espacios deportivos según mis preferencias       | 2            |
| 59     | US23          | Recuperar contraseña     | Como usuario quiero recuperar mi contraseña seguir usando mi cuenta       | 2            |
| 60     | US24          | Conocer acerca de la aplicación            | Como visitante del landing page deseo saber acerca de la aplicación para conocer sus detalles      | 2            |


<br>

# IV. Solution Software Design

## 4.1. Strategic-Level Domain-Driven-Design

En esta sección se presentan diversos enfoques esenciales aplicados en el Diseño Dirigido por el Dominio a nivel estratégico (Strategic-Level Domain-Driven Design). Estas metodologías fueron clave para construir una base robusta en la definición y modelado de dominios complejos. Mediante técnicas como *Event Storming*, *Context Mapping* y la definición de la Arquitectura de Software, se logró una comprensión clara y profunda de los componentes fundamentales necesarios para diseñar sistemas efectivos y bien organizados. A continuación, se detallan los aspectos más relevantes abordados en esta etapa.

### 4.1.1. Event Storming

Se adoptó un enfoque visual y colaborativo que facilitó el modelado del contexto del dominio. Durante este proceso, se analizaron etapas como el descubrimiento de contextos candidatos (*Candidate Context Discovery*), el modelado de flujos de mensajes del dominio (*Domain Message Flows Modeling*) y la elaboración de lienzos de contextos delimitados (*Bounded Context Canvases*).

#### 4.1.1.1. Unstructured Exploration

Es una técnica visual que involucra a todas las partes interesadas con el fin de explorar el dominio del sistema. Se emplean notas adhesivas de varios colores para representar distintos componentes, lo que facilita el diálogo y el descubrimiento de requisitos.


<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//evs1.png" alt="UPC">
</p>

#### 4.1.1.2. Timelines

Hace referencia al orden cronológico de los eventos que tienen lugar dentro del sistema. Representar esta secuencia en una línea de tiempo permite visualizar la interacción entre eventos y su impacto en el flujo de trabajo, además de ayudar a detectar momentos clave en el proceso.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//evs2.png" alt="UPC">
</p>

#### 4.1.1.3. Pain Points

Se trata de los retos o inconvenientes que experimentan los usuarios y las partes interesadas dentro del contexto del sistema. Reconocer estos problemas permite enfocar esfuerzos en priorizar funcionalidades y soluciones que respondan de manera efectiva a las necesidades reales de los usuarios.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//evs3.png" alt="UPC">
</p>

#### 4.1.1.4. Pivotal Points

Corresponden a instantes decisivos dentro del flujo de eventos que pueden alterar el estado del sistema o tener un impacto notable en la experiencia del usuario. Detectarlos permite enfocar los esfuerzos en las áreas de mayor relevancia.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//evs4.png" alt="UPC">
</p>

#### 4.1.1.5. Commands

Representan las acciones o comandos que un usuario o el sistema pueden realizar para generar una modificación en el estado del sistema. Ejemplos de ello son "Crear Pedido" o "Actualizar Inventario".

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//evs5.png" alt="UPC">
</p>

#### 4.1.1.6. Policies

Son normas o lineamientos que establecen cómo deben tomarse las decisiones dentro del sistema. Estas reglas de negocio definen, por ejemplo, cuándo deben ejecutarse determinados comandos o cómo deben gestionarse ciertos eventos.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//evs6.png" alt="UPC">
</p>

#### 4.1.1.7. Read Models

Son estructuras de datos utilizadas para atender consultas o solicitudes de información. Estos modelos de lectura están optimizados para facilitar el acceso a los datos y se mantienen separados de los modelos de escritura, lo que permite mejorar tanto el rendimiento como la escalabilidad del sistema.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//evs7.png" alt="UPC">
</p>

#### 4.1.1.8. External Systems

Hace referencia a otros sistemas o servicios que se comunican con el sistema principal. Identificar estos sistemas es clave para comprender las dependencias e integraciones necesarias para el correcto funcionamiento del sistema.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//evs8.png" alt="UPC">
</p>

#### 4.1.1.9. Aggregates

Son conjuntos de objetos que se manejan como una sola entidad para la gestión de datos y la lógica empresarial. Un agregado asegura la consistencia de sus elementos durante las operaciones y agrupa la lógica de negocio asociada.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//evs9.png" alt="UPC">
</p>

#### 4.1.1.10. Bounded Contexts

Es una delimitación precisa dentro del dominio del sistema en la que se aplica un modelo específico. Establece una frontera donde un conjunto de conceptos y términos adquieren un significado particular, lo que ayuda a evitar confusiones y gestionar las complejidades en sistemas grandes y distribuidos.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//evs10.png" alt="UPC">
</p>

### 4.1.2. Candidate Context Discovery

Usando la metodología de Eventstorming con un enfoque "start-with-simple", empleamos la línea de tiempo para identificar posibles candidatos para nuestro contexto delimitado, los cuales son los siguientes:

**Identificación de Valores del Negocio:** Hemos examinado los valores fundamentales del negocio, como la experiencia del usuario al reservar un espacio deportivo y seleccionar el tipo de reserva, ya sea para jugar con amigos o, si lo prefiere, utilizar nuestro sistema de salas comunitarias, donde los usuarios pueden reunirse con personas que comparten intereses similares en el juego.

**Identificación de Funcionalidades Clave:** Se han destacado las funcionalidades esenciales que permiten una interacción fluida, como la capacidad de realizar reservas, gestionar espacios deportivos, acceder a salas comunitarias, y facilitar la interacción entre los usuarios mediante la creación y participación en eventos y actividades relacionadas con el deporte.

A través de este enfoque, logramos establecer una comprensión clara de los aspectos clave que deben ser gestionados y optimizados para ofrecer una experiencia de usuario coherente y satisfactoria.


**Users:**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//cdiscovery-user.png" alt="UPC">
</p>

**Identity and Access Management:**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//cdiscovery-iam.png" alt="UPC">
</p>

**Subscriptions:**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//cdiscovery-sub.png" alt="UPC">
</p>

**Sport Spaces:**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//cdiscovery-sportspace.png" alt="UPC">
</p>

**Reservations:**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//cdiscovery-reservation.png" alt="UPC">
</p>

**Rooms:**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//cdiscovery-room.png" alt="UPC">
</p>

**Player List:**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//cdiscovery-pl.png" alt="UPC">
</p>

**Chat Room:**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//cdiscovery-chatroom.png" alt="UPC">
</p>

**Deposit:**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//cdiscovery-deposit.png" alt="UPC">
</p>

**Bank Transfer:**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//cdiscovery-banktransfer.png" alt="UPC">
</p>

**Payments:**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//cdiscovery-payment.png" alt="UPC">
</p>

### 4.1.3. Domain Message Flows Modeling

**1. User signing**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//fm1.PNG" alt="UPC">
</p>

**2. Player recharging credits**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//fm2.PNG" alt="UPC">
</p>

**3. Player recharging credits**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//fm3.PNG" alt="UPC">
</p>

**4. Player creating a community reservation**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//fm4.PNG" alt="UPC">
</p>

**5. Player deleting a community reservation**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//fm5.PNG" alt="UPC">
</p>

**6. Owner upgrading subscription**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//fm6.PNG" alt="UPC">
</p>

**7. Owner creating sportspace**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//fm7.PNG" alt="UPC">
</p>

**8. Owner deleting sportspace**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//fm8.PNG" alt="UPC">
</p>

**9. Owner creating bank transfer**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//fm9.PNG" alt="UPC">
</p>

**10. Admin attending bank transfer**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//fm10.PNG" alt="UPC">
</p>

### 4.1.4. Bounded Context Canvases

**1. IAM Context**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bccanvas-iam.PNG" alt="UPC">
</p>

**2. User Context**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bccanvas-user.png" alt="UPC">
</p>

**3. Subscription Context**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bccanvas-sub.png" alt="UPC">
</p>

**4. Deposit Context**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bccanvas-deposit.png" alt="UPC">
</p>

**5. Payment Context**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bccanvas-payment.png" alt="UPC">
</p>

**6. Bank Transfer Context**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bccanvas-banktransfer.png" alt="UPC">
</p>

**7. Sportspace Context**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bccanvas-sportspace.png" alt="UPC">
</p>

**8. Reservation Context**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bccanvas-reservation.png" alt="UPC">
</p>

**9. Room Context**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bccanvas-room.png" alt="UPC">
</p>

**10. Player List Context**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bccanvas-pl.png" alt="UPC">
</p>

**1. Chat Room Context**

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bccanvas-chatroom.PNG" alt="UPC">
</p>

### 4.1.5. Context Mapping

El "Context Mapping" representa cómo los diferentes módulos interactúan entre sí distintos Bounded Contexts dentro de un sistema complejo. Ayuda a entender las relaciones, dependencias y límites entre las diferentes partes de un sistema que tienen sus propios modelos de dominio.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//context-mapping.png" alt="UPC">
</p>

### 4.1.6. Software Architecture

#### 4.1.6.1. Software Architecture System Landscape Diagram

Este diagrama muestra el panorama general del sistema, destacando las principales entidades involucradas, como los Usuarios, Administrador, y las interacciones del sistema de gestión empresarial con componentes externos como la API de Pago (PayPal API), la API de correos Gmail API y la API de mapas (Google Maps API). Representa las conexiones entre estos actores y cómo interactúan con el sistema para proporcionar acceso a funciones clave como pagos, envío de correos y visualización de espacios deportivos en el mapa a tiempo real.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//context-diagram.png" alt="UPC">
</p>

#### 4.1.6.2. Software Architecture Context Level Diagrams

Este diagrama desglosa el contexto a un nivel más detallado, mostrando las interacciones entre los usuarios y el sistema en términos de roles y permisos. Aquí, tanto los Usuarios como los Administradores tienen acceso al Sistema de Gestión Empresarial, pero interactúan de manera diferente, con los usuarios accediendo a características específicas como pagos a través de la API de PayPal, recuperación de contraseña a tráves de la API de Gmail y visualización de espacios deportivos en el mapa a tiempo real a tráves de la API de Google Maps. 

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//context-diagram.png" alt="UPC">
</p>

#### 4.1.6.3. Software Architecture Container Level Diagrams

Aqui especificamos los contenedores de software que soportan la arquitectura, como la Aplicación Web (Web App), la Aplicación Móvil (Mobile App), el lado del servidor (Backend) y los Dispositivos IoT Gestionados (Managed IoT Devices). Aquí también se destacan las conexiones los sistemas externos, con lo que proporciona un mapa claro de cómo los distintos módulos del sistema se comunican entre sí y con componentes externos.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//container-diagram.png" alt="UPC">
</p>

#### 4.1.6.4. Software Architecture Deployment Level Diagrams

El diagrama de deployment representa la arquitectura física del sistema D'Taquito y muestra cómo se distribuyen sus componentes en distintos entornos. En el diagrama se observa:

- Dispositivos de entrada como móviles y sensores, que interactúan con el sistema.

- Una API REST que actúa como punto de entrada para las solicitudes.

- Dentro del servicio desplegado (App Service), se encuentra un monolito modular que agrupa distintos Bounded Contexts (usuarios, pagos, reservas, etc.) dentro de un solo proyecto, organizados por módulos en el mismo código fuente

- Una base de datos MySQL, también desplegada en la nube, que almacena la información del sistema.

Este diagrama ilustra cómo los diferentes elementos del sistema están conectados y dónde se ejecutan, ayudando a comprender su estructura de despliegue.


<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//deployment-diagram.png" alt="UPC">
</p>


## 4.2. Tactical-Level Domain-Driven-Design

### 4.2.1. Bounded Context: Users

#### 4.2.1.1. Domain Layer

##### 4.2.1.1.1. Model

###### 4.2.1.1.1.1. Aggregates

- User: La clase User representa una entidad agregada (aggregate) del dominio de usuarios en el backend del sistema D'Taquito. Actúa como el punto central para gestionar toda la información relacionada a un usuario.

  Contiene los siguientes elementos principales:

  - Atributos básicos como id, name, email, password, y credits.

  - Una relación con la entidad Role para definir el rol del usuario (como estudiante, profesor, admin, etc.).

  - Se construye a partir de un comando (CreateUserCommand) que encapsula los datos necesarios para crear un nuevo usuario.

  - Hereda de AuditableAbstractAggregateRoot, lo que sugiere que registra información de auditoría (como fechas de creación/modificación).

###### 4.2.1.1.1.2. Commands

- CreateUserCommand: Es un comando del dominio que encapsula los datos necesarios para crear un nuevo usuario. Utiliza un Java record para simplificar la estructura y es inmutable por defecto.
Contiene:

  - name: nombre del usuario.

  - email: correo electrónico.

  - password: contraseña.

  - roleId: identificador del rol que se le asignará.

- SeedRoleTypeCommand: Es un comando vacío que se utiliza para inicializar o poblar los tipos de roles en el sistema.

###### 4.2.1.1.1.3. Entities

- ResetPassword: Es una clase de entidad que representa la información necesaria para restablecer la contraseña de un usuario.
Contiene:

  - token: código único para validar la operación de restablecimiento.

  - newPassword: nueva contraseña que se desea establecer.

- Role: Es una entidad persistente que representa los roles de la aplicación. Está mapeada a la tabla role_types en la base de datos.

  Contiene:

  - id: identificador único del rol.

  - roleType: tipo de rol, representado por el enum RoleTypes.

  Incluye un constructor estático fromNameToRole para crear un objeto Role a partir del nombre del rol como cadena.

###### 4.2.1.1.1.4. Events

- UserCreatedEvent: Es un evento de dominio que se lanza cuando se crea un nuevo usuario en el sistema.
Extiende de ApplicationEvent de Spring, lo que permite que otros componentes del sistema reaccionen a este evento de forma desacoplada.

  Contiene:

  - userId: identificador del usuario recién creado.

  - source: objeto que generó el evento (pasado al constructor base).

###### 4.2.1.1.1.5. Queries

- GetUserByIdQuery: Es una consulta del dominio utilizada para obtener los datos de un usuario a partir de su identificador (id).
Utiliza un Java record con validación en su constructor compacto para asegurar que el id no sea nulo.
Si el id es null, lanza una excepción indicando que el identificador es obligatorio.

###### 4.2.1.1.1.6. Value Objects

- RoleTypes: Es un Value Object en forma de enum que define los tipos de roles disponibles en el sistema.

  Representa valores constantes e inmutables que categorizan a los usuarios según su función:

  - PLAYER: usuario jugador.

  - OWNER: usuario propietario.

  - ADMIN: usuario administrador.

##### 4.2.1.1.2. Services

- UserCommandService: Es una interfaz de servicio de dominio que define las operaciones de comando (modificación) relacionadas con la entidad User.
Se encarga de gestionar acciones que cambian el estado del usuario, tales como registro, inicio de sesión y actualizaciones de datos.

  Contiene los siguientes métodos:

  - handle(SignUpCommand command): registra un nuevo usuario.

  - handle(SignInCommand command): autentica al usuario y retorna el usuario junto con un token.

  - updatePassword(Long userId, String newPassword): actualiza la contraseña.

  - updateName(Long userId, String newName): actualiza el nombre.

  - updateEmail(Long userId, String newEmail): actualiza el correo electrónico.

  - handleUserCreatedEvent(UserCreatedEvent event): maneja acciones posteriores a la creación de un usuario.

- UserQueryService: Es una interfaz de servicio de dominio que define las operaciones de consulta (lectura) relacionadas con la entidad User.
Se enfoca en obtener información sin modificar el estado del sistema.

  Contiene los siguientes métodos:

  - handle(GetUserByIdQuery query): obtiene un usuario por su ID.

  - getAllUsers(): retorna una lista de todos los usuarios registrados.

  - getUserRoleByUserId(Long userId): obtiene el rol asignado a un usuario a partir de su ID.

- RoleCommandService: Es una interfaz de servicio de dominio que define la operación de comando relacionada con la entidad Role.
Su objetivo es ejecutar la inicialización de los tipos de roles en el sistema.

  Contiene el método:

  - handle(SeedRoleTypeCommand command): se encarga de poblar los tipos de roles definidos (como PLAYER, OWNER, ADMIN) cuando el sistema lo requiere.

##### 4.2.1.1.3. Exceptions

- InvalidRoleTypeException: Es una excepción personalizada que extiende de RuntimeException.
Se lanza cuando se intenta usar un tipo de rol no válido en el sistema.

Su constructor recibe un mensaje que describe el error, permitiendo identificar fácilmente la causa del problema relacionado con los roles.

##### 4.2.1.1.4. Config

- MailConfig: Es una clase de configuración que define cómo se debe configurar y exponer un JavaMailSender como bean de Spring para el envío de correos electrónicos.

  Características clave:

  - Utiliza la librería Dotenv para cargar variables de entorno desde un archivo .env.

  - Configura los parámetros necesarios como host, puerto, usuario, contraseña y propiedades SMTP adicionales.

  - Crea una instancia de JavaMailSenderImpl con esas configuraciones y la expone como un bean reutilizable en todo el proyecto.

  - Este componente es esencial para funcionalidades como envío de correos de verificación, recuperación de contraseña, etc.

#### 4.2.1.2. Interface Layer

##### 4.2.1.2.1. Resources

- CreateUserResource: Es un record que representa la estructura del cuerpo de la solicitud (request) para crear un nuevo usuario desde la capa REST.
  Contiene: name, email, password y roleId.

- UserResource: Es un record que representa la respuesta (response) enviada al cliente con los datos del usuario.
  Contiene: id, name, email, roleType (como texto) y credits.

- UpdateEmailUserResource: Clase que representa la solicitud para actualizar el correo electrónico de un usuario.
  Contiene: newEmail.

- UpdateNameUserResource: Clase que representa la solicitud para actualizar el nombre de un usuario.
  Contiene: name.

- UpdatePasswordUserResource: Clase que representa la solicitud para actualizar la contraseña de un usuario.
  Contiene: newPassword.

##### 4.2.1.2.2. Transform

- CreateUserCommandFromResourceAssembler: Es una clase transformadora que convierte un CreateUserResource (representación del cuerpo de la solicitud REST) en un CreateUserCommand (comando del dominio).
El método toCommandFromResource toma un CreateUserResource y extrae sus atributos (name, email, password, roleId) para crear un nuevo CreateUserCommand.

- UserResourceFromEntityAssembler: Es una clase transformadora que convierte una entidad User (modelo de dominio) en un UserResource (representación para la respuesta REST).
El método toResourceFromEntity extrae los datos relevantes de la entidad User (como id, name, email, roleType, credits) y los organiza en un UserResource. Además, convierte el roleType a mayúsculas para enviarlo en la respuesta.

##### 4.2.1.2.3. Controllers

- UserController: Es un controlador REST para manejar las operaciones relacionadas con usuarios. Está diseñada para ser parte de un sistema de gestión de usuarios, donde se realizan acciones como el registro de usuarios, actualización de datos, y la obtención de información sobre el usuario autenticado. A continuación, se describe cada método y su funcionalidad:

  - Métodos:
    - createUser (POST /sign-up):

      - Funcionalidad: Registra un nuevo usuario.

      - Validaciones: Verifica que el rol no sea nulo, que el rol sea válido y que el rol no sea "ADMIN". También valida que la contraseña tenga al menos 16 caracteres, contenga mayúsculas, minúsculas, números y caracteres especiales.

      - Proceso: Si todo es válido, crea un nuevo usuario y asigna un plan gratuito al usuario.

      - Respuestas: Si el registro es exitoso, devuelve un mensaje de éxito; si no, devuelve el error correspondiente.

    - getAllUsers (GET /all):

      - Funcionalidad: Obtiene todos los usuarios registrados en el sistema.

      - Validaciones: Solo los usuarios con rol "ADMIN" pueden acceder a esta información.

      - Respuestas: Devuelve la lista de usuarios en formato UserResource si la autenticación es exitosa; si no, devuelve un error de "FORBIDDEN".

    - updateName (PUT /name):

      - Funcionalidad: Actualiza el nombre del usuario autenticado.

      - Validaciones: Requiere que el usuario esté autenticado.

      - Respuestas: Si el usuario es encontrado y el nombre se actualiza, devuelve un mensaje de éxito; de lo contrario, devuelve un error de "NOT FOUND".

    - updateEmail (PUT /email):

      - Funcionalidad: Actualiza el correo electrónico del usuario autenticado.

      - Validaciones: Requiere que el usuario esté autenticado.

      - Respuestas: Si el correo electrónico se actualiza correctamente, invalida la sesión actual y devuelve un mensaje de éxito; si no, devuelve un error de "NOT FOUND".

    - updatePassword (PUT /password):

      - Funcionalidad: Actualiza la contraseña del usuario autenticado.

      - Validaciones: La nueva contraseña debe cumplir con un formato específico.

      - Respuestas: Si la contraseña se actualiza correctamente, invalida la sesión y devuelve un mensaje de éxito; si no, devuelve un error de "NOT FOUND".

    - getAuthenticatedUser (GET /me):

      - Funcionalidad: Obtiene la información del usuario autenticado.

      - Validaciones: Requiere que el usuario esté autenticado.

      - Respuestas: Devuelve la información del usuario en formato UserResource si está autenticado; si no, devuelve un error de "UNAUTHORIZED".

- EmailController: Es un controlador REST que maneja las operaciones de recuperación de contraseñas para los usuarios. Proporciona dos endpoints principales: uno para solicitar un correo de restablecimiento de contraseña y otro para restablecer la contraseña utilizando un token de restablecimiento.

  - Métodos:
    - forgotPassword (POST /forgot-password):

      - Funcionalidad: Este endpoint permite que el usuario solicite un correo para restablecer su contraseña.

      - Proceso: Llama al servicio PasswordResetTokenService para generar un token de restablecimiento de contraseña para el correo proporcionado.

      - Respuestas: Si el token se genera correctamente, responde con un mensaje indicando que se ha enviado un correo para restablecer la contraseña.

    - resetPassword (POST /reset-password):

      - Funcionalidad: Este endpoint permite que el usuario restablezca su contraseña utilizando un token recibido previamente.

      - Validaciones: Verifica que la nueva contraseña no esté vacía. La nueva contraseña debe cumplir con un formato específico (mínimo 16 caracteres, al menos una letra mayúscula, una minúscula, un número y un carácter especial).

      - Proceso: Se valida el token recibido. Si es válido, se obtiene el correo del usuario asociado con el token. Luego, se busca al usuario en la base de datos utilizando su correo electrónico. Si el usuario existe, se encripta la nueva contraseña y se guarda en la base de datos.

      - Respuestas: Si el proceso es exitoso, responde con un mensaje de éxito. Si algo falla (token inválido, usuario no encontrado, etc.), devuelve un mensaje de error.


#### 4.2.1.3. Application Layer

##### 4.2.1.3.1. Command Services

- UserCommandServiceImpl: Gestiona la creación y actualización de usuarios, y el inicio de sesión.

  - Métodos clave:

    - updatePassword, updateName, updateEmail: Actualizan la contraseña, el nombre o el correo de un usuario, respectivamente.

    - handleUserCreatedEvent: Recibe eventos de creación de usuario (por ejemplo, al crear un usuario, publicando un evento UserCreatedEvent).

    - handle(SignUpCommand command): Registra un nuevo usuario. Valida que los parámetros estén completos (rol, correo, contraseña), crea un nuevo usuario, y luego emite un evento de creación.

- RoleCommandServiceImpl: Gestiona los roles de usuario en el sistema.

  - Método clave:

    - handle(SeedRoleTypeCommand command): Este método inicializa los roles en la base de datos usando los valores predefinidos de RoleTypes. Se ejecuta automáticamente durante la inicialización de la aplicación con la anotación @PostConstruct.

- PasswordResetTokenService: Gestiona la creación y envío de tokens para restablecer la contraseña de un usuario.

  - Método clave:

    - createPasswordResetTokenForUser: Busca un usuario por correo electrónico, genera un token de restablecimiento de contraseña usando el EmailService y lo envía al correo del usuario.

- EmailService: Se encarga del envío de correos electrónicos para el restablecimiento de contraseñas y la generación de tokens JWT.

  - Métodos clave:

    - sendPasswordResetEmail: Envía un correo con un enlace que contiene el token de restablecimiento de contraseña.

    - generatePasswordResetToken: Genera un token JWT para restablecimiento de contraseña, que tiene una fecha de expiración configurada desde un archivo .env.

    - getEmailFromToken: Extrae el correo electrónico del usuario a partir de un token JWT.

##### 4.2.1.3.2. Query Services

- UserQueryServicesImpl: Implementa el servicio para consultar información sobre usuarios, basándose en el repositorio UserRepository para acceder a la base de datos. Aquí están los detalles clave de cada uno de los métodos que ofrece:

  - Métodos:

    - getAllUsers(): Recupera todos los usuarios de la base de datos.

      - Implementación: Utiliza el método findAll() del UserRepository para obtener una lista completa de usuarios.

      - Retorno: Devuelve una lista de objetos User.

    - getUserRoleByUserId(Long userId): Obtiene el rol de un usuario dado su userId.

      - Implementación: Busca el usuario por ID y, si se encuentra, devuelve el tipo de rol (RoleType) del usuario. Si no se encuentra el usuario, devuelve null.

      - Retorno: El nombre del rol del usuario como una cadena, o null si el usuario no se encuentra.

    - handle(GetUserByIdQuery query): Recupera un usuario dado un ID proporcionado en el GetUserByIdQuery.

      - Implementación: Valida que el userId no sea null. Busca el usuario en la base de datos utilizando el userRepository. Si no se encuentra el usuario, lanza una excepción NoSuchElementException. Si el usuario se encuentra, se devuelve el objeto User encapsulado en un Optional.

      - Retorno: Un Optional<User> que contiene el usuario si se encuentra, o una excepción si no.

##### 4.2.1.3.3. Event Handlers

- UserCreatedEventHandler: Está diseñada para manejar el evento UserCreatedEvent, el cual es disparado cuando un nuevo usuario es creado en el sistema. La clase se encarga de escuchar este evento y ejecutar un flujo de acciones en respuesta a su ocurrencia.

  - Métodos:
    - on(UserCreatedEvent event): Este método está anotado con @EventListener, lo que indica que debe ser ejecutado cuando se reciba un UserCreatedEvent.
      - Acción: Este método maneja el evento a nivel de comandos, permitiendo realizar alguna acción relacionada con la creación del usuario, como por ejemplo actualizar un registro o notificar otros componentes del sistema.

#### 4.2.1.4. Infrastructure Layer

- UserRepository: es un repositorio de acceso a datos de tipo JPA (Java Persistence API) que extiende de JpaRepository, lo que permite realizar operaciones CRUD sobre la entidad User. Está anotada con @Repository, lo que la marca como un componente de la capa de persistencia en Spring, permitiendo que se maneje automáticamente las excepciones relacionadas con la base de datos (a través de DataAccessException).

  - Métodos:
    - Optional<User> findByEmailAndPassword(String email, String password): Este método busca un usuario en la base de datos utilizando su correo electrónico (email) y su contraseña (password). Devuelve un Optional<User>, lo que permite manejar correctamente la posibilidad de que no se encuentre ningún usuario con esas credenciales.

    - Optional<User> findByEmail(String email): Este método busca un usuario por su correo electrónico (email). También devuelve un Optional<User>, lo que asegura que si no se encuentra el usuario con el correo proporcionado, se puede manejar adecuadamente la situación.


#### 4.2.1.5. Bounded Context Software Architecture Component Level Diagrams

Este diagrama ilustra la arquitectura del sistema a nivel de componentes dentro de un contexto delimitado. Se basa en los principios de DDD para reflejar cómo ha sido estructurado el sistema. Muestra los distintos componentes, cada uno responsable de una funcionalidad específica, y cómo interactúan entre sí mediante el intercambio de mensajes para satisfacer los requerimientos del negocio. La base de datos se representa como el repositorio central de información, accesible por los distintos servicios. Este diagrama es fundamental para comprender la organización modular del sistema y la manera en que se gestiona el flujo de información entre los componentes.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//user-component.png" alt="UPC">
</p>

#### 4.2.1.6. Bounded Context Software Architecture Code Level Diagrams

##### 4.2.1.6.1 Bounded Context Domain Layer Class Diagrams

Aquí se detalla la arquitectura del software a nivel de código, presentando la clase User dentro del contexto de dominio. El diagrama muestra los atributos de la clase y métodos asociados.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//dcode-user.png" alt="UPC">
</p>

##### 4.2.1.6.2. Bounded Context Database Design Diagram 

Este diagrama representa el diseño de la base de datos dentro de un Bounded Context específico del sistema. En él se detallan las entidades principales, sus atributos clave y las relaciones entre ellas, según las responsabilidades y límites funcionales de cada contexto. Su objetivo es proporcionar una visión clara y aislada de cómo se estructuran y gestionan los datos dentro de ese contexto, asegurando una alta cohesión interna y una baja dependencia con otros contextos del dominio.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//db-user.png" alt="UPC">
</p>

### 4.2.2. Bounded Context: IAM

#### 4.2.2.1. Domain Layer

##### 4.2.2.1.1. Model

###### 4.2.2.1.1.1. Commands

- SignInCommand: Comando para iniciar sesión; contiene el email y la contraseña del usuario.

- SignUpCommand: Comando para registrar un nuevo usuario; incluye el nombre, email, contraseña y el rol (objeto Role).
- 
###### 4.2.2.1.1.2. Queries

- GetAllRolesQuery: Consulta que se usa para obtener todos los roles existentes en el sistema.

- GetRoleByNameQuery: Consulta que permite buscar un rol específico usando su nombre (RoleTypes).

##### 4.2.2.1.2. Services

- RoleQueryService: Interfaz de servicio que define operaciones para consultar roles.

    - handle(GetAllRolesQuery query): Devuelve una lista con todos los roles.

    - handle(GetRoleByNameQuery query): Devuelve un rol específico según su nombre (RoleTypes), si existe.

#### 4.2.2.2. Interface Layer
##### 4.2.2.2.1. Resources

- SignUpResource: Datos necesarios para registrarse (nombre, correo, contraseña, rol).

- SignInResource: Datos para iniciar sesión (correo y contraseña).

- RoleResource: Representación de un rol (ID y nombre).

- AuthenticatedUserResource: Respuesta al iniciar sesión exitosamente (ID, nombre de usuario y token).

##### 4.2.2.2.2. Transform

- SignUpCommandFromResourceAssembler: Transforma un SignUpResource recibido del cliente en un SignUpCommand para la capa de dominio. Convierte el nombre del rol (String) en un objeto Role.

- SignInCommandFromResourceAssembler: Convierte un SignInResource en un SignInCommand, permitiendo que los datos de inicio de sesión pasen a la capa de aplicación.

- AuthenticatedUserResourceFromEntityAssembler: Transforma un objeto de dominio User y un token JWT en un AuthenticatedUserResource, que será enviado como respuesta al cliente luego de autenticarse.

##### 4.2.2.2.3. Controllers

- AuthenticationController: Gestiona las operaciones de autenticación en la API.

  - Endpoints:
      - POST /api/v1/authentication/sign-in

        - Recibe un SignInResource con correo y contraseña.
        
        - Usa UserCommandService para autenticar.

          Si es exitoso:
          - Genera un token JWT.
          - Retorna un AuthenticatedUserResource.
          - Guarda el token en una cookie HTTP-only llamada JWT_TOKEN.

      - GET /api/v1/authentication/is-authenticated

        - Verifica si el usuario actual está autenticado.

        - Retorna { "authenticated": true/false }.

      - POST /api/v1/authentication/log-out

        - Invalida la cookie JWT_TOKEN estableciendo su duración en 0.

        - No requiere cuerpo.


#### 4.2.2.3. Application Layer

##### 4.2.2.3.1. OutBound Services

###### 4.2.2.3.1.1. Hashing

- HashingService: Interfaz que define métodos para codificar contraseñas y verificar coincidencias.

  - Métodos:
    - String encode(CharSequence rawPassword)
      - Codifica la contraseña en texto plano.

    - boolean matches(CharSequence rawPassword, String encodedPassword)
      - Compara una contraseña sin codificar con una codificada.

###### 4.2.2.3.1.2. Tokens

- TokenService: Interfaz encargada de la generación, extracción de datos y validación de tokens JWT.

  - Métodos:
    - String generateToken(String email, String userId, String role)
      - Genera un JWT con información del usuario.

    - String getEmailFromToken(String token)
      - Extrae el correo electrónico desde un token.

    - String getUserIdFromToken(String token)
      - Extrae el ID del usuario desde un token.

    - boolean validateToken(String token)
      - Verifica si un token es válido y no ha expirado.

##### 4.2.2.3.2. Query Services

- RoleQueryServiceImpl: Implementación de la interfaz RoleQueryService, encargada de manejar las consultas relacionadas con los roles de usuario.

  - Métodos:
    - List<Role> handle(GetAllRolesQuery query)
      - Retorna todos los roles disponibles desde el repositorio.

    - Optional<Role> handle(GetRoleByNameQuery query)
      - Busca un rol específico por su tipo (RoleTypes), por ejemplo: ADMIN, USER, etc.

  - Dependencia:
    - RoleRepository
      - Repositorio JPA para acceder a la entidad Role.

##### 4.2.2.3.3. Event Handlers

- ApplicationReadyEventHandler: Esta clase maneja el evento ApplicationReadyEvent que se dispara cuando la aplicación de Spring Boot está completamente cargada y lista para ejecutarse. Su propósito principal es verificar si es necesario sembrar los roles en la base de datos al arrancar la aplicación.

  - Funcionalidad: Escucha el evento ApplicationReadyEvent. Cuando la aplicación está lista (ApplicationReadyEvent), se invoca el método on() para ejecutar la verificación y, si es necesario, se realiza la siembra de roles utilizando el servicio RoleCommandService.

  - Dependencias
    - RoleCommandService: Servicio que maneja los comandos relacionados con los roles de usuario, específicamente el comando SeedRoleTypeCommand.

  - Metodología
    - on(ApplicationReadyEvent event): Registra un mensaje en los logs indicando que se va a verificar la necesidad de sembrar los roles. Ejecuta el comando SeedRoleTypeCommand para sembrar los roles predeterminados si corresponde.

    - currentTimestamp(): Método auxiliar que obtiene la fecha y hora actual para loguear la información.

  - Logs: Utiliza SLF4J para registrar el estado del proceso de siembra de roles, incluyendo el nombre del contexto de la aplicación y la hora exacta en la que se realiza cada paso.


#### 4.2.2.4. Infrastructure Layer

##### 4.2.2.4.1. Authorization

###### 4.2.2.4.1.1. Configuration

- WebSecurityConfiguration: Anotada con @Configuration y @EnableMethodSecurity, habilita seguridad a nivel de método y define los beans relacionados con la autenticación, autorización y filtros.

- Dependencias Inyectadas:

  - UserDetailsService (calificado como "defaultUserDetailsService")

  - BearerTokenService: para la gestión de tokens JWT.

  - BCryptHashingService: usado como codificador de contraseñas.

  - AuthenticationEntryPoint: maneja accesos no autorizados (401).

- Beans Principales:
  
  - BearerAuthorizationRequestFilter: filtro que intercepta las peticiones para validar el token Bearer.

  - AuthenticationManager: gestor principal de autenticación.

  - DaoAuthenticationProvider: configura cómo se autentican los usuarios (con UserDetailsService y PasswordEncoder).

  - PasswordEncoder: implementado por BCryptHashingService.

- Método filterChain() – Configuración Principal: Este método define cómo se asegura cada solicitud HTTP.

  - CORS: Permite solicitudes desde orígenes específicos

  - CSRF: CSRF activado con tokens almacenados en cookies (no HTTP only).

  - Autorización: 

    - Se permite acceso sin autenticación a:

      - Endpoints de autenticación (/api/v1/authentication/**)

      - Swagger (/swagger-ui/**, /v3/api-docs/**)

      - Registro de usuario (POST /api/v1/users/sign-up)

      - Validación de QR (POST /api/v1/reservations/use-qr-token/validate)

      - Info del usuario (GET /api/v1/users/me)

      - Recuperación de contraseña

    - Todo lo demás requiere estar autenticado.

- Manejo de Sesiones:

  - Política STATELESS: no se guarda estado de sesión entre solicitudes.

- Filtros:

  - Se agrega el filtro BearerAuthorizationRequestFilter antes del filtro de autenticación estándar (UsernamePasswordAuthenticationFilter).

###### 4.2.2.4.1.2. Model

- UserDetailsImpl: Implementa la interfaz UserDetails de Spring Security, que representa al usuario autenticado.

  - Metodos:

    - public static UserDetailsImpl build(User user):

      - Propósito: Crea una instancia de UserDetailsImpl a partir de un objeto User de nuestra base de datos.

      - Qué hace:

        - Toma el id, email, password y el role del usuario.

        - Crea una autoridad (SimpleGrantedAuthority) a partir del nombre del rol (user.getRole().getRoleType().name()).

        - Retorna un nuevo UserDetailsImpl.

    - @Override public String getUsername():

      - Propósito: Devuelve el identificador único del usuario, que en este caso es el email.

      - Spring Security usa esto para hacer login.

- UsernamePasswordAuthenticationTokenBuilder: 

  - Metodos:

    - public static UsernamePasswordAuthenticationToken build(UserDetails principal, HttpServletRequest request):

      - Propósito: Construye el token de autenticación que representa al usuario.

      - Qué hace: 

        - Crea un UsernamePasswordAuthenticationToken usando: 
        
          - UserDetails (principal) como identidad.

          - null como credenciales (ya autenticado).

          - Sus authorities (permisos/roles).

          - Asigna los detalles de la request (IP, User-Agent, etc.) usando WebAuthenticationDetailsSource.

          - Devuelve el token listo para ser colocado en el contexto de seguridad (SecurityContextHolder).

###### 4.2.2.4.1.3. Pipelines

- UnauthorizedRequestHandlerEntryPoint:

  - Propósito: Maneja accesos no autorizados.
  
  - Método: 
  
    - commence(): Envía un HTTP 401 cuando un usuario no autenticado accede a una ruta protegida.

- BearerAuthorizationRequestFilter:

  - Propósito: Filtra cada request para verificar si tiene un token Bearer válido.

  - Método:

    - doFilterInternal(): 
      
      - Extrae el token del header Authorization.

      - Valida el token.

      - Si es válido:

      - Obtiene el email del token.

      - Carga el usuario.

      - Configura la autenticación en el contexto de seguridad.

      - Si algo falla, continúa el flujo y lo registra.

###### 4.2.2.4.1.4. Services

- UserDetailsServiceImpl:

  - Propósito: Provee los detalles del usuario a Spring Security.

  - Metodo:

    - loadUserByUsername(String email):

      - Busca al usuario por correo en la base de datos.

      - Si lo encuentra, lo transforma en un UserDetailsImpl (adaptador para Spring Security).

      - Si no lo encuentra, lanza UsernameNotFoundException.

#### 4.2.2.5. Bounded Context Software Architecture Component Level Diagrams 

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//iam-component.png" alt="UPC">
</p>

#### 4.2.2.6. Bounded Context Software Architecture Code Level Diagrams

##### 4.2.2.6.1. Bounded Context Domain Layer Class Diagrams 


Aquí se detalla la arquitectura del software a nivel de código, presentando la clase IAM dentro del contexto de dominio. El diagrama muestra los atributos de la clase y métodos asociados.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//dcode-iam.png" alt="UPC">
</p>

### 4.2.3. Bounded Context: Subscriptions

#### 4.2.3.1. Domain Layer

##### 4.2.3.1.1. Model

###### 4.2.3.1.1.1. Aggregates

- Subscription: La clase Subscription representa una entidad agregada (aggregate) del dominio de suscripcion en el backend del sistema D'Taquito. Actúa como el punto central para gestionar toda la información relacionada a una suscripcion.

  Contiene los siguientes elementos principales:

  - Atributos:

    - Plan plan:

      - Relación ManyToOne con Plan.

      - Identifica a qué plan está suscrito el usuario.

      - Obligatorio (nullable = false).

    - User user:

      - Relación ManyToOne con User.

      - Identifica qué usuario tiene esta suscripción.

      - Oculto en respuestas JSON (@JsonProperty.WRITE_ONLY).

    - int allowedSportSpaces:

      - Número de espacios deportivos permitidos por la suscripción.

      - Por defecto en 0.

  - Constructores:
    
    - Constructor vacío (para JPA)

    - Constructor que recibe un Plan y un User

  - Métodos:
    
    - update(Plan plan):

      - Cambia el plan de la suscripción.

    - updateAllowedSportSpaces(int allowedSportSpaces):

      - Actualiza la cantidad de espacios deportivos permitidos.

  - Hereda de AuditableAbstractAggregateRoot, lo que sugiere que registra información de auditoría (como fechas de creación/modificación).

###### 4.2.3.1.1.2. Commands

- CreateSubscriptionsCommand
  
  - Tipo: record.

  - Propósito: Representa el comando para crear una suscripción.

  - Atributos:

  - Long planId: ID del plan al que se va a suscribir el usuario.

  - Long userId: ID del usuario que realiza la suscripción.

  - String token: Token asociado a la suscripción, para validación o autenticación.

- SeedPlanTypesCommand
  - Tipo: record.

  - Propósito: Representa el comando para sembrar tipos de planes (inicializar datos de planes en la base de datos).

  - Atributos: Ninguno, solo se utiliza como marcador para la acción de siembra de planes.

###### 4.2.3.1.1.3. Entities

- Plan
  
  - Propósito: Representa un tipo de plan en la base de datos. Se utiliza para definir las distintas opciones de planes disponibles para las suscripciones.

  - Atributos:

    - Long id: ID único del plan, generado automáticamente.

    - PlanTypes planType: Tipo del plan (utiliza un enum que define los posibles tipos de planes, como bronce, plata, oro, etc.).

  - Anotaciones:

    - @Entity: Indica que es una entidad persistente de JPA.

    - @Table(name = "plan_types"): Especifica el nombre de la tabla en la base de datos que almacena los tipos de planes.

    - @Id y @GeneratedValue: Define el campo id como la clave primaria y establece la generación automática de su valor.

    - @Column(nullable = false): Marca la columna planType como no nula.

    - @Enumerated(EnumType.STRING): Especifica que el valor de planType será almacenado como una cadena de texto (nombre del enum).

  - Constructores:

    - Constructor vacío por defecto (Plan()).

    - Constructor que recibe un PlanTypes planType para crear una nueva instancia del plan.

###### 4.2.3.1.1.4. Events

- SubscriptionCreatedEvent

  - Propósito: Representa un evento que se dispara cuando se crea una nueva suscripción en el sistema. Este evento puede ser escuchado por otros componentes del sistema para realizar acciones posteriores a la creación de una suscripción.

  - Atributos:

    - Long subscriptionId: ID de la suscripción que fue creada. Es el identificador único de la suscripción que se acaba de crear.

  - Herencia:

    - Extiende de ApplicationEvent, que es una clase de Spring utilizada para definir eventos de aplicación. Esto permite que el evento sea publicado y escuchado dentro del contexto de la aplicación.

  - Constructor:

    - SubscriptionCreatedEvent(Object source, Long subscriptionId): Constructor que recibe dos parámetros:

      - source: El objeto que origina el evento (usualmente la clase que publica el evento).

      - subscriptionId: El ID de la suscripción recién creada.

  - Métodos:

    - getSubscriptionId(): Método getter que devuelve el ID de la suscripción asociada con el evento.

###### 4.2.3.1.1.5. Queries

- GetSubscriptionsByIdQuery

  - Propósito: Este record es una consulta (query) que se utiliza para obtener una suscripción específica a partir de su ID. Es una estructura de datos inmutable que contiene los detalles necesarios para realizar una búsqueda en la base de datos.

  - Atributos:

    - Long id: El ID de la suscripción que se quiere obtener.

  - Constructor: El constructor del record es implícito, pero incluye una validación:

    - Si el id es null, se lanza una excepción IllegalArgumentException con el mensaje "Id is required". Esto garantiza que siempre se proporciona un ID válido para la consulta.

  - Métodos:

    - El record no necesita métodos adicionales para acceder al id, ya que el record de Java proporciona automáticamente un getter para los atributos.

###### 4.2.3.1.1.6. Value Objects

- PlanTypes 

  - Propósito: El enum PlanTypes representa los diferentes tipos de planes disponibles en el sistema. Este tipo de datos enumera las posibles opciones de planes que un usuario puede tener.

  - Valores:

    - FREE: Plan gratuito.

    - BRONZE: Plan básico.

    - SILVER: Plan intermedio.

    - GOLD: Plan premium.

  - Uso:

    - Este enum se utiliza principalmente en la clase Plan para asignar un tipo de plan a un objeto Plan. Cada tipo de plan tiene una representación única dentro de la aplicación, lo que facilita la gestión de diferentes niveles de acceso o características basadas en el tipo de plan asignado.

##### 4.2.3.1.2. Services

- SubscriptionsCommandService: Responsable de manejar comandos relacionados con suscripciones.

  - Optional<Subscription> handle(CreateSubscriptionsCommand command): Procesa la creación de una nueva suscripción a partir de un comando.

  - void handleSubscriptionCreatedEvent(SubscriptionCreatedEvent event): Maneja acciones posteriores a la creación de una suscripción, como eventos o registros.

- SubscriptionsQueryService: Responsable de manejar consultas sobre suscripciones.

  - Optional<Subscription> handle(GetSubscriptionsByIdQuery query): Devuelve una suscripción según su ID.

  - Optional<Subscription> getSubscriptionByUserId(Long userId): Busca la suscripción correspondiente a un usuario por su ID.

- PlanCommandService: Responsable de comandos relacionados con los tipos de planes.

  - void handle(SeedPlanTypesCommand command): Permite registrar los tipos de planes en el sistema, útil para inicializar datos.


#### 4.2.3.2. Interface Layer

##### 4.2.3.2.1. Resources

- CreateSubscriptionsResource: Representa los datos necesarios para crear una nueva suscripción desde una solicitud REST.

  - Long planId: ID del plan al que se desea suscribir.

  - Long userId: ID del usuario que se va a suscribir.

  - String token: Token de autorización o pago.

  - Long allowedSportSpaces: Cantidad de espacios deportivos permitidos en el plan.

- SubscriptionsResource: Representa los datos que se devuelven al cliente al consultar una suscripción.

  - Long id: ID de la suscripción.

  - Long planId: ID del plan asociado.

  - User user: Objeto usuario relacionado con la suscripción.

  - String planType: Tipo de plan (FREE, BRONZE, SILVER, GOLD).

  - Long allowedSportSpaces: Número de espacios deportivos permitidos.

##### 4.2.3.2.2. Transform

- CreateSubscriptionsCommandFromResourceAssembler: Convierte un recurso REST (CreateSubscriptionsResource) en un comando de dominio (CreateSubscriptionsCommand), que luego puede ser manejado por la capa de aplicación.

  - Método:
    - toCommandFromResource(CreateSubscriptionsResource resource): Extrae los valores del recurso y los pasa al constructor del comando. Devuelve una instancia de CreateSubscriptionsCommand.

- SubscriptionsResourceFromEntityAssembler: Convierte una entidad de dominio (Subscription) en un recurso REST (SubscriptionsResource), usado para responder al cliente.

  - Método:
    - toResourceFromEntity(Subscription entity): Extrae los campos necesarios de la entidad, incluyendo el tipo de plan y usuario. Devuelve una instancia de SubscriptionsResource.

##### 4.2.3.2.3. Controllers

- SubscriptionsController: Este controlador maneja la gestión de suscripciones de los usuarios en la aplicación, incluyendo la visualización, actualización de plan mediante pagos con PayPal, y la gestión del resultado del pago (éxito o cancelación).

  - Endpoints:

      - PUT /api/v1/subscriptions/upgrade
        
        - Permite a los usuarios con rol OWNER actualizar su plan de suscripción, solo los lunes entre las 00:00 y 06:00 (hora Lima).
        - Se inicia un pago con PayPal y se devuelve la approval_url.

      - GET /api/v1/subscriptions/upgrade/success
        
        - Callback que PayPal llama cuando el usuario completa el pago.

        - Verifica si el pago fue aprobado.

        - Si es así, actualiza el plan de suscripción y los espacios deportivos permitidos.

        - Redirige a una página de confirmación o error.

      - GET /api/v1/subscriptions/upgrade/cancel
        
        - Callback que PayPal llama si el usuario cancela el pago.

        - Marca la transacción como cancelada.

      - GET /api/v1/subscriptions

        - Devuelve los datos de suscripción del usuario autenticado.

#### 4.2.3.3. Application Layer

##### 4.2.3.3.1. Command Services

- SubscriptionsCommandServiceImpl: Gestiona la creación o actualización de suscripciones para los usuarios.
Además, publica un evento SubscriptionCreatedEvent cuando se crea una nueva suscripción.

  - Métodos clave:

    - handle(CreateSubscriptionsCommand command): 
      
      - Busca al usuario por su userId. 
      
      - Busca el plan con el planId proporcionado. 
      
      - Si no existe, utiliza el plan FREE por defecto.

      - Si el usuario ya tiene suscripciones, las actualiza con el nuevo plan.

      - Si el usuario no tiene suscripciones, crea una nueva.

      - Publica un evento SubscriptionCreatedEvent.

      - Devuelve la suscripción creada o actualizada.

    - handleSubscriptionCreatedEvent(SubscriptionCreatedEvent event): Solo imprime un mensaje indicando que se recibió el evento. Este método puede ser ampliado más adelante para realizar acciones concretas al recibir dicho evento.

- PlanCommandServiceImpl: Se encarga de registrar los tipos de planes (PlanTypes) en la base de datos cuando la aplicación se inicia.

  - Método clave:

    - init(): Este método se ejecuta automáticamente al iniciar la aplicación (por la anotación @PostConstruct). Invoca al método handle para registrar los planes.

    - handle(SeedPlanTypesCommand command): Recorre todos los valores definidos en PlanTypes (por ejemplo: FREE, BRONZE, SILVER, GOLD). Si alguno no existe en la base de datos, lo guarda.

##### 4.2.3.3.2. Query Services

- SubscriptionsQueryServiceImpl: Proporciona servicios para consultar información sobre suscripciones. Es la implementación de la interfaz SubscriptionsQueryService.

  - Métodos:

    - handle(GetSubscriptionsByIdQuery query): Recupera todos los usuarios de la base de datos.

      - Entrada: un objeto GetSubscriptionsByIdQuery que contiene el id de la suscripción.

      - Salida: devuelve una Optional<Subscription> con la suscripción correspondiente, si existe.

    - getSubscriptionByUserId(Long userId)(Long userId): Obtiene el rol de un usuario dado su userId.

      - Entrada: el userId del usuario.

      - Salida: devuelve una Optional<Subscription> con la primera suscripción del usuario, si tiene alguna.

##### 4.2.3.3.3. Event Handlers

- SubscriptionCreatedEventHandler: Maneja los eventos de tipo SubscriptionCreatedEvent. Es responsable de ejecutar acciones cuando una suscripción es creada, como registrar un evento y consultar los detalles de la suscripción recién creada.

  - Métodos:
    - on(SubscriptionCreatedEvent event):

      - Entrada: un evento de tipo SubscriptionCreatedEvent que contiene el subscriptionId de la suscripción creada.

      - Salida: No devuelve nada.

      - Descripción: Este método se ejecuta automáticamente cuando se recibe un evento de tipO SubscriptionCreatedEvent. Realiza las siguientes acciones:

        - Llama al método handleSubscriptionCreatedEvent del SubscriptionsCommandService para procesar cualquier lógica adicional relacionada con la creación de la suscripción.

        - Usa el SubscriptionsQueryService para consultar los detalles de la suscripción recién creada mediante el GetSubscriptionsByIdQuery.

        - Imprime un mensaje en consola indicando si la suscripción fue encontrada o no.


#### 4.2.3.4. Infrastructure Layer

- SubscriptionsRepository: Es una interfaz que extiende JpaRepository para interactuar con la base de datos en relación a las entidades de tipo Subscription. Permite realizar operaciones CRUD estándar sobre las suscripciones.

  - Métodos:
    
    - findByUserId(Long userId): Este método encuentra todas las suscripciones asociadas a un usuario específico, identificado por userId.

      - Retorna: Una lista de suscripciones asociadas al userId proporcionado.

- PlanRepository: Es una interfaz que extiende JpaRepository para interactuar con la base de datos en relación a las entidades de tipo Plan. Permite realizar operaciones CRUD estándar sobre los planes.

  - Métodos:
    
    - existsByPlanType(PlanTypes planType): Verifica si existe un plan con el tipo específico planType.

      - Retorna: Un valor booleano (true si existe un plan de ese tipo, false en caso contrario).

    - findByPlanType(PlanTypes planType): Busca un plan en la base de datos que coincida con el tipo de plan planType.

      - Retorna: Un Optional<Plan>, que contiene el plan si lo encuentra, o Optional.empty() si no existe.

#### 4.2.3.5. Bounded Context Software Architecture Component Level Diagrams 

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//subscription-component.png" alt="UPC">
</p>

#### 4.2.3.6. Bounded Context Software Architecture Code Level Diagrams 

##### 4.2.3.6.1. Bounded Context Domain Layer Class Diagrams 

Aquí se detalla la arquitectura del software a nivel de código, presentando la clase subscription dentro del contexto de dominio. El diagrama muestra los atributos de la clase y métodos asociados.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//dcode-sub.png" alt="UPC">
</p>

##### 4.2.3.6.2. Bounded Context Database Design Diagram 

Este diagrama representa el diseño de la base de datos dentro de un Bounded Context específico del sistema. En él se detallan las entidades principales, sus atributos clave y las relaciones entre ellas, según las responsabilidades y límites funcionales de cada contexto. Su objetivo es proporcionar una visión clara y aislada de cómo se estructuran y gestionan los datos dentro de ese contexto, asegurando una alta cohesión interna y una baja dependencia con otros contextos del dominio.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bd-subs.png" alt="UPC">
</p>

### 4.2.4. Bounded Context: Sport Spaces

#### 4.2.4.1. Domain Layer 

##### 4.2.4.1.1. Model

##### 4.2.4.1.1.1. Aggregates

- SportSpace: Representa un espacio deportivo, gestionando información como el nombre, deporte, imagen, precio, dirección, horarios, y el número de jugadores permitidos según el modo de juego. Además, valida que los datos de precios y jugadores sean correctos conforme al deporte y modo de juego seleccionados

  - Metodos:

    - SportSpaces(CreateSportSpacesCommand command, User user, Sport sport): Constructor que inicializa un nuevo espacio deportivo con los datos del comando, el usuario propietario y el deporte asociado.

    - update(CreateSportSpacesCommand command, Sport sport): Actualiza los detalles de un espacio deportivo existente con los datos proporcionados en el comando y el deporte asociado.

    - validateGameMode(): Valida que el número de jugadores y el precio sean coherentes con el modo de juego y el deporte, y que las restricciones de deporte y modo de juego sean correctas.

##### 4.2.4.1.1.2. Commands

- CreateSportSpacesCommand: Esta clase representa un comando para crear un nuevo espacio deportivo. Se asegura de que todos los campos necesarios (nombre, deporte, imagen, precio, distrito, dirección, descripción, horarios, y modo de juego) estén presentes y correctamente definidos. Si algún campo requerido está vacío o nulo, lanza una excepción IllegalArgumentException.

  - Metodo: 
    
    - CreateSportSpacesCommand: Inicializa el comando con los parámetros necesarios para crear un nuevo espacio deportivo. Verifica que todos los campos obligatorios (nombre, deporte, imagen, etc.) no estén vacíos ni nulos. Si alguna propiedad está incorrecta, lanza una excepción de tipo IllegalArgumentException.

- SeedSportTypeCommand: Clase vacía que se usa para la inicialización o "semilla" de los tipos de deporte en el sistema. Es un comando sin lógica propia, usado para agregar datos iniciales de tipos de deporte.

  - Metodo: 
    
    - SeedSportTypeCommand: Es un comando sin campos ni lógica, utilizado para algún proceso de inicialización o carga de datos para tipos de deportes en el sistema.

##### 4.2.4.1.1.3. Entities

- Sport: Representa un deporte específico dentro del sistema. Está asociada con el tipo de deporte (por ejemplo, fútbol, billar) a través de un valor enumerado SportTypes. Esta clase está diseñada para ser persistida en la base de datos y usa JPA para la gestión de su estado.

  - Metodos: 

    - Sport(): Constructor vacio utilizado por JPA para la creacion de instancias de la entidad.

    - Sport(SportTypes sportType): Inicializa un nuevo objeto Sport con un tipo de deporte específico, que se pasa como parámetro en el constructor.

##### 4.2.4.1.1.4. Events

- SportSpacesCreatedEvent: Representa un evento que ocurre cuando se crea un nuevo espacio deportivo (SportSpace). Este evento es utilizado en el sistema para notificar a otros componentes o servicios sobre la creación de un nuevo espacio deportivo, y contiene el identificador del espacio creado.

  - Metodos: 

    - SportSpacesCreatedEvent(Object source, Long id): Inicializa un evento SportSpacesCreatedEvent con el origen del evento (por ejemplo, el objeto que originó el evento) y el identificador (id) del espacio deportivo recién creado.

##### 4.2.4.1.1.5. Queries

- GetSportSpacesByUserIdQuery: es una consulta utilizada para obtener los espacios deportivos asociados a un usuario, identificados por su userId. Esta consulta lanza una excepción si el userId no se proporciona.

  - Metodos:

    - GetSportSpacesByUserIdQuery(Long userId): Inicializa la consulta con el userId y valida que no sea nulo. Si userId es nulo, lanza una excepción de tipo IllegalArgumentException.

- GetSportSpacesByIdQuery: es una consulta utilizada para obtener un espacio deportivo específico, identificado por su id. Si el id no se proporciona, se lanza una excepción.

  - Métodos:

    - GetSportSpacesByIdQuery(Long id): Inicializa la consulta con el id y valida que no sea nulo. Si id es nulo, lanza una excepción de tipo IllegalArgumentException.

##### 4.2.4.1.1.6. Value Objects

- SportTypes: es un enum que define los tipos de deportes disponibles. Actualmente, contiene dos valores: FUTBOL y BILLAR.

- GameMode: es un enum que define los modos de juego posibles para los deportes, especificando el número máximo de jugadores para cada modalidad. Incluye los siguientes modos:

  - Métodos:

    - getMaxPlayers(): Devuelve el número máximo de jugadores para el modo de juego.

- District: es un enum que define los distritos de la ciudad de Lima donde se pueden ubicar los espacios deportivos. Algunos de los distritos definidos son San_Miguel, San_Borja, Miraflores, entre otros.

##### 4.2.4.1.2. Services

- SportSpacesCommandService: Define operaciones de comando relacionadas con la creación, actualización y gestión de espacios deportivos.

  - Metodos:

    - Optional<SportSpaces> handle(Long id, CreateSportSpacesCommand command): Crea un nuevo espacio deportivo.

    - Optional<SportSpaces> handleUpdate(Long id, CreateSportSpacesCommand command): Actualiza un espacio deportivo existente.

    - void handleSportSpacesCreatedEvent(SportSpacesCreatedEvent event): Maneja el evento posterior a la creación de un espacio deportivo.

    - byte[] getImageById(Long id): Devuelve la imagen asociada a un espacio deportivo.

- SportSpacesQueryService: Define operaciones de consulta relacionadas con los espacios deportivos.

  - Metodos: 

    - Optional<SportSpaces> handle(GetSportSpacesByIdQuery query): Obtiene un espacio deportivo por su ID.
    
    - List<SportSpaces> getAllSportSpaces(): Obtiene todos los espacios deportivos registrados.

    - List<SportSpaces> handle(GetSportSpacesByUserIdQuery query): Obtiene los espacios deportivos publicados por un usuario específico.

    - boolean isSportSpaceAvailable(Long sportSpaceId, String date, String openTime, String closeTime): Verifica si un espacio deportivo está disponible en una fecha y horario específicos.
  
- SportCommandService: Define comandos relacionados con la inicialización de tipos de deporte.

  - Metodos: void handle(SeedSportTypeCommand command): Registra los tipos de deportes iniciales en el sistema (como Fútbol o Billar).

#### 4.2.4.2. Interface Layer

##### 4.2.4.2.1. Resources

- CreateSportSpacesResource: Recurso utilizado para recibir datos desde el cliente al crear un nuevo espacio deportivo.

- SubscriptionsResource: Recurso usado para devolver información de un espacio deportivo al cliente.

##### 4.2.4.2.2. Transform

- CreateSportSpacesCommandFromResourceAssembler: Convierte un CreateSportSpacesResource (entrada del cliente) en un CreateSportSpacesCommand (comando para lógica de dominio).

  - Método:
    - toCommandFromResource(CreateSportSpacesResource resource): Crea y retorna un CreateSportSpacesCommand usando los datos del recurso.

- SportSpacesResourceFromEntityAssembler: Convierte una entidad de dominio SportSpaces en un SportSpacesResource (salida hacia el cliente).

  - Método:
    - toResourceFromEntity(SportSpaces entity): Mapea todos los campos de la entidad a un recurso legible para el cliente, incluyendo imagen, tipo de deporte, distrito, modo de juego, etc.

##### 4.2.4.2.3. Controllers

- SportSpacesController: Este controlador maneja operaciones relacionadas con espacios deportivos (como canchas, salones, etc.). Solo los usuarios con rol OWNER pueden crear o eliminar espacios deportivos, y el acceso a otras funciones depende del tipo de usuario y su plan de suscripción (BRONZE, SILVER, GOLD, etc.).

  - Endpoints:

      - POST /api/v1/sport-spaces
      
          - Permite a un usuario con rol OWNER y un plan válido crear un nuevo espacio deportivo.

        - Validaciones:

          - El usuario debe tener el rol OWNER.

          - El usuario debe tener un plan distinto de FREE.

          - La hora de apertura y cierre debe estar entre las 6:00 y las 22:00.

        - Respuestas:

          - 201 Created: Espacio creado exitosamente.

          - 400 Bad Request: Datos inválidos (horarios fuera de rango).

          - 403 Forbidden: Usuario no tiene permiso para crear espacios.

      - DELETE /api/v1/sport-spaces/{sportSpaceId}
          
          - Permite al OWNER eliminar un espacio deportivo propio.

        - Validaciones:

          - El usuario debe ser el creador del espacio (verificado por ID).

          - El espacio no debe tener reservas futuras.

        - Respuestas:

          - 200 OK: Espacio eliminado correctamente.

          - 403 Forbidden: Usuario no autorizado.

          - 409 Conflict: Existen reservas futuras, no se puede eliminar.

      - GET /api/v1/sport-spaces
         
          - Retorna todos los espacios deportivos disponibles en el sistema.

        - Restricción:

          - No accesible por usuarios con rol OWNER.

        - Respuestas:

          - 200 OK: Lista de espacios disponibles.

          - 403 Forbidden: Acceso denegado a usuarios OWNER.

      - GET /api/v1/sport-spaces/user
          
          - Devuelve todos los espacios deportivos creados por el usuario autenticado (solo OWNER).

        - Respuestas:

          - 200 OK: Lista de espacios del usuario.

          - 403 Forbidden: Usuario no es OWNER.

      - GET /api/v1/sport-spaces/{sportSpaceId}
          
          - Devuelve los detalles de un espacio deportivo específico según su ID.

        - Respuestas:

          - 200 OK: Detalles del espacio deportivo.

          - 404 Not Found: No existe un espacio con el ID indicado.

      - GET /api/v1/sport-spaces/{sportSpaceId}/availability

          - Devuelve la disponibilidad horaria del espacio deportivo para la semana actual.
          
        - Respuestas:

          - 200 OK: (cuando esté implementado) Mapa de horarios disponibles por día.

          - 404 Not Found: Si el espacio no existe.

#### 4.2.4.3. Application Layer

##### 4.2.4.3.1. Command Services

- SportSpacesCommandServiceImpl: Gestiona la creación de espacios deportivos para los usuarios.

  - Métodos clave:

    - handle(Long userId, CreateSportSpacesCommand command):

      - Crea un nuevo espacio deportivo.

      - Verifica que el usuario y el deporte existan.

      - Lanza excepción si el deporte no existe.

      - Guarda el espacio en el repositorio y lo retorna.

    - handleUpdate(Long id, CreateSportSpacesCommand command):

      - Actualiza un espacio deportivo existente.

      - Busca el espacio por ID, lanza excepción si no lo encuentra.

      - Busca el nuevo deporte asociado y actualiza el espacio.

      - Guarda los cambios en el repositorio.

    - handleSportSpacesCreatedEvent(SportSpacesCreatedEvent event):

      - Maneja eventos de creación de espacios deportivos.

      - Imprime en consola un mensaje con el ID del espacio.

    - getImageById(Long id):

      - Retorna la imagen asociada a un espacio deportivo.

      - Lanza excepción si no encuentra el espacio con el ID.

- SportCommandServiceImpl: Se encarga de registrar los tipos de deportes (SportTypes) en la base de datos cuando la aplicación se inicia.

  - Método clave:

    - init(): Este método se ejecuta automáticamente al iniciar la aplicación (por la anotación @PostConstruct). Invoca al método handle para registrar los deportes.

    - handle(SeedSportTypeCommand  command): Recorre todos los valores definidos en SportTypes. Si alguno no existe en la base de datos, lo guarda.

##### 4.2.4.3.2. Query Services

- SportSpacesQueryServiceImpl: Proporciona servicios para consultar información sobre sport spaces. Es la implementación de la interfaz SportSpacesQueryService.

  - Métodos:

    - handle(GetSportSpacesByIdQuery query): Retorna un espacio deportivo basado en el ID proporcionado en la consulta.

      - Utiliza el repositorio SportSpacesRepository para buscar el espacio.

    - getAllSportSpaces(): Retorna una lista de todos los espacios deportivos almacenados en la base de datos.

      - Utiliza el repositorio SportSpacesRepository para obtener la información.

    - handle(GetSportSpacesByUserIdQuery query): Retorna una lista de espacios deportivos asociados a un usuario, según el ID de usuario proporcionado en la consulta

      - Utiliza el repositorio SportSpacesRepository para realizar la búsqueda.

    - isSportSpaceAvailable(Long sportSpaceId, String date, String openTime, String closeTime): Verifica si un espacio deportivo está disponible en una fecha y horario específicos.

      - Utiliza un método personalizado del repositorio SportSpacesRepository para verificar la disponibilidad.

##### 4.2.4.3.3. Event Handlers

- SportSpacesCreatedEventHandler: Maneja los eventos de tipo SportSpacesCreatedEvent. Es responsable de ejecutar acciones cuando un sport space es creada, como registrar un evento y consultar los detalles de la sport space recién creada.

  - Métodos:
    - on(SportSpacesCreatedEvent event):

      - Este método escucha el evento SportSpacesCreatedEvent y ejecuta una serie de acciones cuando el evento es recibido.

#### 4.2.4.4. Infrastructure Layer

- SportSpacesRepository: Capa de conexion con la base de datos.

  - findByUserId(Long userId):

    - Busca todos los espacios deportivos asociados a un usuario específico, dado su userId.

    - Devuelve una lista de SportSpaces.

  - isSportSpaceAvailable(Long sportSpaceId, String gameDay, String startTime, String endTime):

    - Verifica si un espacio deportivo está disponible para una reserva en un día y hora específicos.

    - Utiliza una consulta personalizada (@Query) para comprobar si existe alguna reserva que se superponga con los tiempos proporcionados (startTime y endTime).

    - La consulta también verifica que la reserva esté dentro del horario de apertura y cierre del espacio deportivo.

- SportRepository: Capa de conexion a la base de datos.

  - existsBySportType(SportTypes sportType):

    - Verifica si existe un deporte con el tipo de deporte especificado (sportType).

    - Devuelve un valor booleano: true si el tipo de deporte ya está presente en la base de datos, false si no lo está.

#### 4.2.4.5. Bounded Context Software Architecture Component Level Diagrams

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//sportspace-component.png" alt="UPC">
</p>

#### 4.2.4.6. Bounded Context Software Architecture Code Level Diagrams 

##### 4.2.4.6.1. Bounded Context Domain Layer Class Diagrams 

Aquí se detalla la arquitectura del software a nivel de código, presentando la clase sportspace dentro del contexto de dominio. El diagrama muestra los atributos de la clase y métodos asociados.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//dcode-sportspace.png" alt="UPC">
</p>

##### 4.2.4.6.2. Bounded Context Database Design Diagram 

Este diagrama representa el diseño de la base de datos dentro de un Bounded Context específico del sistema. En él se detallan las entidades principales, sus atributos clave y las relaciones entre ellas, según las responsabilidades y límites funcionales de cada contexto. Su objetivo es proporcionar una visión clara y aislada de cómo se estructuran y gestionan los datos dentro de ese contexto, asegurando una alta cohesión interna y una baja dependencia con otros contextos del dominio.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bd-sport.png" alt="UPC">
</p>

### 4.2.5. Bounded Context: Reservations

#### 4.2.5.1. Domain Layer

##### 4.2.5.1.1. Model

##### 4.2.5.1.1.1. Aggregates

- Reservations: es una entidad que representa una reserva de un espacio deportivo realizada por un usuario. Esta clase extiende de AuditableAbstractAggregateRoot, lo que le permite tener funcionalidades de auditoría como la creación y actualización de registros. Cada reserva está asociada a un usuario (user) y a un espacio deportivo (sportSpaces), con información sobre el día del juego (gameDay), hora de inicio (startTime), hora de finalización (endTime), estado de la reserva (status), tipo de reserva (type), y un nombre de la reserva (reservationName).

  - Metodos:

    - Constructor Reservations(CreateReservationsCommand command, User user, SportSpaces sportSpaces): Este constructor se utiliza para crear una nueva instancia de Reservations.

    - Recibe un CreateReservationsCommand que contiene los detalles de la reserva (día del juego, horas de inicio y fin, tipo de reserva, etc.), un User (usuario que realiza la reserva) y un SportSpaces (espacio deportivo reservado).

    - Inicializa las propiedades gameDay, startTime, endTime, user, sportSpaces, type y reservationName.

##### 4.2.5.1.1.2. Commands

- CreateReservationsCommand: es un record en Java, lo que significa que es una clase inmutable que contiene los parámetros necesarios para crear una nueva reserva. Este comando encapsula información sobre la reserva, incluyendo el día del juego (gameDay), la hora de inicio (startTime), la hora de finalización (endTime), el ID del espacio deportivo (sportSpacesId), el tipo de reserva (type) y el nombre de la reserva (reservationName).

  - Metodo: 
    
    - CreateReservationsCommand: El constructor valida los parámetros recibidos para asegurar que ninguno de los campos necesarios sea nulo. Si algún campo obligatorio está nulo, se lanza una excepción IllegalArgumentException con un mensaje correspondiente.

##### 4.2.5.1.1.3. Entities

- QRCodeGenerator: Se encarga de generar y validar tokens JWT (JSON Web Tokens) que se utilizan para autenticar y validar las reservas de espacios deportivos a través de códigos QR. El token incluye información relevante sobre la reserva, como el reservationId, el userId, las horas de inicio y fin de la reserva, y el día del juego. Además, la clase permite verificar si un token ya ha sido utilizado.

  - Metodos: 

    - QRCodeGenerator(): Constructor de la clase que carga una clave secreta de un archivo .env (utilizando la librería Dotenv), que se usa para firmar los tokens JWT con el algoritmo HMAC SHA.

    - generateQrToken(Long reservationId, Long userId, String startTimeStr, String endTimeStr, String gameDayStr): Este método genera un token JWT que contiene información sobre una reserva de espacio deportivo.

    - validateQrToken(String token): Este método valida un token JWT. Utiliza la clave secreta para verificar la autenticidad del token.

    - checkIfTokenUsed(String token): Este método verifica si un token JWT ya ha sido utilizado, revisando una caché local de tokens utilizados.

    - markTokenAsUsed(String token): Este método marca un token como utilizado, agregándolo a la caché de tokens utilizados.

##### 4.2.5.1.1.4. Events

- ReservationCreatedEvent: es un evento de dominio que se utiliza para notificar cuando una nueva reserva ha sido creada en el sistema. Esta clase extiende ApplicationEvent, que es una clase de Spring Framework, y se utiliza para la implementación de eventos que pueden ser escuchados y procesados por otros componentes del sistema.

  - Metodos: 

    - ReservationCreatedEvent(Object source, Long reservationId): Constructor que inicializa el evento con el objeto que lo originó (source) y el ID de la reserva (reservationId).

    - getReservationId(): Devuelve el ID de la reserva asociada con este evento.

      - Retorno: Long - El ID de la reserva.

##### 4.2.5.1.1.5. Queries

- GetReservationsByUserIdQuery: es un objeto de consulta utilizado para obtener las reservas asociadas a un usuario específico. Esta clase implementa el patrón Query Object, que se usa para representar una solicitud de datos o información. El objeto es inmutable y contiene el userId como parámetro para realizar la consulta.

  - Metodos:

    - GetReservationsByUserIdQuery(Long userId)(Long userId): Constructor que inicializa el objeto con el ID del usuario.

##### 4.2.5.1.1.6. Value Objects

- Status: Es un enum que representa el estado de una reserva.

  - PENDING: La reserva está pendiente de confirmación.

  - CONFIRMED: La reserva ha sido confirmada.

  - CONCLUDED: La reserva ha finalizado.

  - CANCELLED: La reserva ha sido cancelada.

- Type: Es un enum que representa el tipo de reserva.

  - PERSONAL: La reserva es de carácter personal, probablemente para uso exclusivo del usuario.

  - COMMUNITY: La reserva es de carácter comunitario, probablemente destinada para grupos o eventos.

##### 4.2.5.1.2. Services

- ReservationsCommandService: Esta interfaz define los servicios relacionados con la gestión de comandos de reservas, como la creación de nuevas reservas y la eliminación de reservas que cumplen ciertas condiciones.

  - Metodos:

    - handle(Long id, CreateReservationsCommand command): Maneja la creación de una reserva basada en el comando CreateReservationsCommand. Devuelve una Optional<Reservations> con la reserva creada si es exitosa.

    - handleReservationsCreatedEvent(ReservationCreatedEvent event): Maneja el evento de creación de una reserva. Este evento probablemente se utiliza para realizar acciones adicionales o notificaciones tras la creación de la reserva.

    - deleteReservationsByOneHourBefore(): Método programado para ejecutarse cada 60 segundos. Este método eliminaría reservas que están a punto de comenzar en una hora, probablemente para limpiar aquellas que ya no sean relevantes o que no hayan sido confirmadas.

    - deletePersonalReservationByEndTimeConcluded(): Método programado que ejecuta cada 60 segundos, para eliminar las reservas personales que hayan terminado y cuya condición sea "concluida".

- ReservationsQueryService: Esta interfaz define los servicios relacionados con las consultas de reservas. 

  - Metodos: 

    - handle(GetReservationsByUserIdQuery query): Maneja la consulta para obtener las reservas asociadas a un usuario específico mediante GetReservationsByUserIdQuery.

    - getAllReservations(): Obtiene todas las reservas sin filtrar por usuario, proporcionando una lista de todas las reservas en el sistema.

#### 4.2.5.2. Interface Layer

##### 4.2.5.2.1. Resources

- CreateReservationsResource: Esta clase es un record que representa la estructura de datos para la creación de una nueva reserva. Se utiliza generalmente para recibir los datos necesarios para crear una reserva.

- ReservationsResource: Esta clase también es un record, pero representa una reserva existente, mostrando los detalles de una reserva, como la fecha, hora de inicio, hora de fin, el usuario que la hizo, el espacio deportivo, y el estado de la reserva.

##### 4.2.5.2.2. Transform

- CreateReservationsCommandFromResourceAssembler: Esta clase tiene como objetivo transformar un objeto CreateReservationsResource en un objeto CreateReservationsCommand. Se utiliza en el proceso de conversión de datos entre las capas de presentación (como las solicitudes HTTP) y las capas de lógica de negocio (como los comandos que manipulan la reserva).

  - Método:
    - toCommandFromResource(CreateReservationsResource resource): Toma un CreateReservationsResource y lo convierte en un CreateReservationsCommand.

      - Asocia los valores del resource (como gameDay, startTime, endTime, etc.) con los parámetros del constructor de CreateReservationsCommand.

- ReservationsResourceFromEntityAssembler: Esta clase convierte una entidad Reservations (que representa una reserva en la base de datos) en un recurso ReservationsResource (que se utiliza para responder a las solicitudes REST).

  - Método:
    - toResourceFromEntity(Reservations entity): Convierte una entidad Reservations a un ReservationsResource.

      - Extrae los valores de la entidad Reservations, como id, gameDay, startTime, endTime, status, etc., y los asigna a un nuevo ReservationsResource.

##### 4.2.5.2.3. Controllers

- ReservationsController : Este controlador gestiona las reservas de espacios deportivos y las interacciones con los usuarios mediante varios endpoints.

  - Endpoints:

      - POST /api/v1/reservations:
        
        - Crea una nueva reserva para un espacio deportivo, validando los créditos, la disponibilidad y las restricciones de horario.

      - DELETE /api/v1/reservations/{reservationId}:
        
        - Elimina una reserva existente, verificando si se cumplen las condiciones para realizar la eliminación (espacio lleno o tiempo cercano al inicio).

      - GET /api/v1/reservations/my:
        
        - Obtiene las reservas activas del usuario autenticado.

      - GET /api/v1/reservations/qr-session/{sessionId}:
        
        - Genera un código QR para una sesión de reserva específica.

      - GET /api/v1/reservations/verify-qr:
        
        - Verifica la validez de un código QR basado en un token y devuelve la imagen del QR.

      - POST /api/v1/reservations/use-qr:
        
        - Marca el token QR como utilizado y valida su autenticidad.

#### 4.2.5.3. Application Layer

##### 4.2.5.3.1. Command Services

- ReservationsCommandServiceImpl: Gestiona la lógica de negocio relacionada con las reservas de espacios deportivos.

  - Métodos clave:

    - handle(Long id, CreateReservationsCommand command):
      
      - Crea una nueva reserva de un espacio deportivo, validando la existencia de un usuario y el espacio deportivo.

    - handleReservationsCreatedEvent(ReservationCreatedEvent event):
      
      - Recibe un evento de creación de reserva y muestra el ID de la reserva creada.

    - deleteReservationsByOneHourBefore():
      
      - Elimina las reservas comunitarias que tienen menos de una hora antes de su inicio, verificando si las salas están llenas y procesando la eliminación de las salas asociadas.

    - deletePersonalReservationByEndTimeConcluded():
    
      - Elimina las reservas personales que ya han finalizado, basándose en la hora de finalización de la reserva.

##### 4.2.5.3.2. Query Services

- ReservationsQueryServiceImpl: Proporciona los servicios de consulta relacionados con las reservas.

  - Métodos:

    - handle(GetReservationsByUserIdQuery query):
    
      - Este método recibe una consulta con el ID de usuario y devuelve una lista de reservas asociadas a ese usuario. Utiliza el repositorio de reservas para obtener los datos.

    - getAllReservations():
      
      - Este método devuelve todas las reservas disponibles en la base de datos, sin filtrar por usuario.

##### 4.2.5.3.3. Event Handlers

- ReservationsCreatedEventHandler: Maneja los eventos de creación de reservas y realiza las acciones correspondientes al recibir un ReservationCreatedEvent.

  - Métodos:
    - Constructor (ReservationsCreatedEventHandler):
      
      - El constructor recibe los servicios ReservationsCommandService y ReservationsQueryService para interactuar con los comandos y consultas relacionadas con las reservas.

    - on(ReservationCreatedEvent event):
      
      - Este método es un listener de eventos que se activa cuando se recibe un evento de tipo ReservationCreatedEvent.

      - Imprime un mensaje indicando que el evento ha sido recibido.

      - Llama al método handleReservationsCreatedEvent del servicio ReservationsCommandService para procesar el evento de creación de la reserva.

      - Realiza una consulta para obtener las reservas asociadas al ID del evento utilizando ReservationsQueryService.

      - Imprime un mensaje indicando si la reserva fue creada correctamente o no se encontró.

#### 4.2.5.4. Infrastructure Layer

- ReservationsRepository: es una extensión de JpaRepository que proporciona acceso a la persistencia de datos de la entidad Reservations en la base de datos.

  - findByUserId(Long userId):
    
    - Este método encuentra todas las reservas asociadas a un usuario específico, utilizando su userId. Retorna una lista de reservas.

  - findBySportSpacesIdAndGameDay(Long sportSpacesId, String gameDay):
    
    - Este método encuentra todas las reservas de un espacio deportivo (sportSpacesId) en un día específico (gameDay). También retorna una lista de reservas.

#### 4.2.5.5. Bounded Context Software Architecture Component Level Diagrams

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//reservation-component.png" alt="UPC">
</p>

#### 4.2.5.6. Bounded Context Software Architecture Code Level Diagrams

##### 4.2.5.6.1. Bounded Context Domain Layer Class Diagrams 

Aquí se detalla la arquitectura del software a nivel de código, presentando la clase reservations dentro del contexto de dominio. El diagrama muestra los atributos de la clase y métodos asociados.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//dcode-reservation.png" alt="UPC">
</p>

##### 4.2.5.6.2. Bounded Context Database Design Diagram

Este diagrama representa el diseño de la base de datos dentro de un Bounded Context específico del sistema. En él se detallan las entidades principales, sus atributos clave y las relaciones entre ellas, según las responsabilidades y límites funcionales de cada contexto. Su objetivo es proporcionar una visión clara y aislada de cómo se estructuran y gestionan los datos dentro de ese contexto, asegurando una alta cohesión interna y una baja dependencia con otros contextos del dominio.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bd-reservations.png" alt="UPC">
</p>

### 4.2.6. Bounded Context: Rooms

#### 4.2.6.1. Domain Layer

##### 4.2.6.1.1. Model

##### 4.2.6.1.1.1. Aggregates

- Rooms: Representa una entidad de sala, probablemente en el contexto de un sistema de reservas de espacios deportivos, y está mapeada a una tabla en la base de datos utilizando JPA.

  - Metodos:

    - @OneToMany(mappedBy = "room"):
      
      - Indica que la relación con PlayerList es de uno a muchos y que el campo "room" en PlayerList es el responsable de la relación. La carga se realiza de manera perezosa (FetchType.LAZY), lo que significa que los playerLists solo se cargan cuando se accede a ellos.

    - @ManyToOne y @JoinColumn:
      
      - Establece la relación muchos a uno con la entidad Reservations. La columna reservations_id en la base de datos es la que maneja esta relación.

- Views: define una vista pública (Public), probablemente utilizada para controlar la visibilidad de los atributos cuando se serializa la entidad a JSON o cuando se define el acceso a los datos según el contexto.

##### 4.2.6.1.1.2. Commands

- CreateRoomCommand: es un record de Java que se utiliza para encapsular los datos necesarios para crear una nueva sala. Un record es una clase inmutable que simplifica la creación de clases que solo contienen datos.

##### 4.2.6.1.1.3. Queries

- GetRoomByUserIdQuery: es un record en Java que representa una consulta para obtener información sobre una sala basada en el userId.

  - Metodos:

    - GetRoomByUserIdQuery: El constructor incluye una validación para asegurarse de que el userId no sea null. Si el userId es null, se lanza una excepción IllegalArgumentException con el mensaje "UserId is required". Esta validación garantiza que siempre se proporcione un userId válido al crear una instancia de este record.

##### 4.2.6.1.2. Services

- RoomsCommandService: Define las operaciones que alteran el estado de las salas.

  - Metodos:

    - deleteRoomByEndTimeConcluded:
      
      - Este método es ejecutado periódicamente cada 60 segundos (gracias a la anotación @Scheduled). Su propósito es eliminar salas cuya actividad ha concluido, según alguna lógica asociada a su tiempo de finalización.

    - transferToCreator:

      - Este método transfiere la propiedad o control de una sala al creador de la misma. Toma un objeto Rooms como parámetro.

    - refundToUsers:

      - Este método se encarga de realizar un reembolso a los usuarios. Recibe el playerListsId (id de la lista de jugadores) como parámetro para identificar a los usuarios que deben ser reembolsados.

    - addPlayerToRoomAndChat:

      - Permite añadir un jugador a una sala y también al chat asociado a la sala, usando el roomId (id de la sala) y userId (id del usuario) como parámetros.

    - isRoomCreator:

      - Verifica si un usuario dado es el creador de una sala específica. Recibe como parámetros el roomId y userId y devuelve un valor booleano.

- RoomsQueryService: Define los métodos para consultar la información de las salas sin modificar su estado.

  - Metodos:

    - getAllRooms:
      
      - Recupera una lista de todas las habitaciones disponibles.

    - handle(GetRoomByUserIdQuery query):
      
      - Maneja la consulta para obtener las habitaciones asociadas a un usuario específico, utilizando un GetRoomByUserIdQuery como parámetro.

    - handleFindRoomsUserJoined:
      
      - Recupera las habitaciones en las que un usuario específico se ha unido, utilizando el userId.

    - handleFindRoomsBySportSpacesOwner:
      
      - Recupera las habitaciones asociadas a un propietario de espacios deportivos, utilizando el userId del propietario.

#### 4.2.6.2. Interface Layer

##### 4.2.6.2.1. Resources

- CreateRoomsResource: Contiene la información necesaria para crear una nueva sala (reserva y lista de jugadores).

- ReservationDTO: Representa los detalles de una reserva (nombre, hora, usuario, espacio deportivo).

- RoomResource: Información sobre una sala, incluyendo la reserva y el número de jugadores.

- SportSpaceDTO: Datos de un espacio deportivo (nombre, dirección, tipo de deporte, precio, etc.).

##### 4.2.6.2.2. Transform

- CreateRoomsCommandFromResourceAssembler: Convierte un objeto CreateRoomsResource en un CreateRoomCommand para crear una nueva sala.

  - Método:
    - toCommandFromResource(CreateRoomsResource resource): Convierte el recurso CreateRoomsResource en un comando CreateRoomCommand, que es usado para crear una nueva sala.

- RoomsResourceFromEntityAssembler: Convierte un objeto Rooms en un RoomResource que contiene la información de la reserva, el espacio deportivo y el número de jugadores.

  - Método:
    - toResourceFromEntity(Rooms room): Convierte una entidad Rooms en un RoomResource, que incluye detalles de la reserva, espacio deportivo y el conteo de jugadores (actual/máximo).

##### 4.2.6.2.3. Controllers

- RoomsController: Este controlador proporciona varios endpoints relacionados con la gestión de salas. Aquí hay un resumen breve de sus métodos:

  - Endpoints:

      - GET /api/v1/rooms/{id}
        
        - Recupera una sala específica por su id.

        - Autenticación: Requiere autenticación.

        - Rol necesario: Creador de la sala o jugador de la sala.

        - Respuesta: 200 OK con la información de la sala, 401 si no está autenticado, 403 si el usuario no pertenece a la sala.

      - GET /api/v1/rooms/my-rooms

        - Recupera todas las salas asociadas al usuario autenticado.

        - Autenticación: Requiere autenticación.

        - Rol necesario: Cualquier rol.

        - Respuesta: 200 OK con la lista de salas, 400 si la autenticación no es válida.

      - GET /api/v1/rooms/my-join-rooms

        - Recupera las salas en las que el usuario autenticado ha sido invitado (no creadas por él).

        - Autenticación: Requiere autenticación.

        - Rol necesario: Cualquier rol.

        - Respuesta: 200 OK con la lista de salas filtradas, 400 si la autenticación no es válida.

      - GET /api/v1/rooms/my-rooms-by-spaces
        
        - Recupera todas las salas asociadas a los espacios deportivos que el usuario autenticado posee (solo para usuarios con rol de propietario).

        - Autenticación: Requiere autenticación.

        - Rol necesario: OWNER (propietario de espacio deportivo).

        - Respuesta: 200 OK con la lista de salas, 403 si el rol del usuario no es adecuado.

      - GET /api/v1/rooms/all

        - Recupera todas las salas disponibles (solo para usuarios con rol de jugador).

        - Autenticación: Requiere autenticación.

        - Rol necesario: PLAYER (jugador).

        - Respuesta: 200 OK con la lista de salas, 403 si el rol del usuario no es adecuado, 400 si la autenticación no es válida.

      - POST /api/v1/rooms
      
        - Crea una nueva sala asociada a una reserva y una lista de jugadores.

        - Autenticación: Requiere autenticación.

        - Rol necesario: PLAYER o OWNER (según la lógica del sistema).

        - Respuesta: 201 Created con la información de la sala creada, 400 si los datos son incorrectos, 401 si el usuario no está autenticado.

      - PUT /api/v1/rooms/{id}
        
        - Actualiza una sala específica por su id.

        - Autenticación: Requiere autenticación.

        - Rol necesario: Creador de la sala.

        - Cuerpo de la solicitud: Datos de la sala a actualizar.

        - Respuesta: 200 OK con la sala actualizada, 404 si la sala no se encuentra, 403 si el usuario no tiene permisos.

#### 4.2.6.3. Application Layer 

##### 4.2.6.3.1. Command Services

- ReservationsCommandServiceImpl: es una implementación de la interfaz RoomsCommandService, y se encarga de manejar la lógica de negocio relacionada con las operaciones de las salas (rooms) en el sistema. Su objetivo principal es gestionar la interacción de los usuarios con las salas de juego, asegurando que se cumplan ciertas reglas de negocio, como los pagos, el manejo de los jugadores, la gestión de los chats y la eliminación de salas que ya han concluido.

  - Métodos clave:

    - deleteRoomByEndTimeConcluded()
      
      - Este método se ejecuta cada 60 segundos (gracias a @Scheduled), y elimina las salas cuyo tiempo de finalización ha pasado y están completas. También transfiere el monto acumulado a la cuenta del creador de la sala si la sala está llena.

      - Operaciones:

        - Revisa todas las salas.

        - Verifica si la reserva de la sala ha terminado y si la sala está llena.

        - Si la sala está llena y ha terminado, cambia su estado a "CONCLUDED", borra el chat asociado, elimina los jugadores y finalmente elimina la sala.

    - transferToCreator(Rooms room)

      - Transfiere el monto acumulado en una sala al creador de la sala.

      - Operaciones:

        - Obtiene el monto acumulado de la sala.

        - Agrega ese monto a los créditos del creador de la sala.

        - Guarda la actualización del creador en el repositorio de usuarios.

    - refundToUsers(Long roomId)
      
      - Reembolsa el monto acumulado de una sala a los jugadores.

      - Operaciones:

        - Calcula el monto a devolver a cada jugador en función del número de jugadores en la sala.

        - Se asegura de que la sala tenga jugadores y reembolsa el monto acumulado a cada uno.

    - addPlayerToRoomAndChat(Long roomId, Long userId)

      - Añade un jugador a una sala y a su chat asociado.

      - Operaciones:

        - Verifica que la sala no esté llena y que el jugador no esté ya en la sala.

        - Comprueba si el jugador tiene suficientes créditos para unirse.

        - Descuenta los créditos del jugador, acumula el monto en la sala y guarda ambos.

        - Añade al jugador a la lista de jugadores de la sala y lo vincula con el chat asociado.

    - isRoomCreator(Long roomId, Long userId)
        
      - Verifica si un usuario es el creador de una sala.

      - Operaciones:

        - Verifica si el usuario especificado es el creador de la sala comparando el ID del usuario con el ID del creador de la reserva de la sala.

##### 4.2.6.3.2. Query Services

- RoomsQueryServiceImpl: es una implementación de la interfaz RoomsQueryService y se encarga de manejar las consultas relacionadas con las salas (rooms) en el sistema. Esta clase permite recuperar información de las salas en función de distintos criterios, como el usuario que realiza la consulta, el propietario del espacio deportivo o las salas en las que un usuario está involucrado.

  - Métodos:

    - getAllRooms(): Recupera todas las salas almacenadas en el repositorio de datos. Este método se utiliza para obtener una lista completa de las salas sin ningún filtro.

    - handle(GetRoomByUserIdQuery query): Recibe una consulta (GetRoomByUserIdQuery) que contiene un ID de usuario, y retorna todas las salas que están reservadas por ese usuario. Es útil cuando se quiere obtener las salas asociadas a un usuario específico.

    - handleFindRoomsUserJoined(Long userId): Este método recupera las salas en las que un usuario está participando. Esto puede incluir tanto salas que el usuario haya creado como salas en las que se ha unido.

    - handleFindRoomsBySportSpacesOwner(Long userId): Recupera las salas que están asociadas a un propietario de espacio deportivo. Este método es útil para obtener las salas relacionadas con los espacios deportivos que un usuario posee.

#### 4.2.6.4. Infrastructure Layer 

- RoomsRepository: es un repositorio de acceso a datos en Spring Data JPA, diseñada para manejar operaciones de persistencia relacionadas con la entidad Rooms

  - Metodos:

    - findByReservationsId(Long reservationId): Este método usa una consulta personalizada (@Query) para recuperar todas las salas (Rooms) cuyo reservation.id coincida con el ID proporcionado. Se utiliza para obtener las salas basadas en una reserva específica.

    - findRoomsByReservationUserId(Long userId): Recupera todas las salas cuyas reservas estén asociadas a un usuario específico. Utiliza el parámetro userId para hacer la consulta sobre la relación entre el usuario y las reservas de las salas.

    - findRoomsByUserId(Long userId): Este método obtiene todas las salas en las que un usuario específico está involucrado. La consulta se basa en la relación entre la entidad PlayerList (que relaciona a los jugadores con las salas) y el ID del usuario. Retorna las salas en las que un usuario es parte de la lista de jugadores.

    - findRoomsBySportSpaceOwnerId(Long userId): Recupera todas las salas cuyo espacio deportivo esté asociado a un propietario específico. Utiliza el userId del propietario del espacio deportivo para realizar la consulta.

#### 4.2.6.5. Bounded Context Software Architecture Component Level Diagrams 

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//room-component.png" alt="UPC">
</p>

#### 4.2.6.6. Bounded Context Software Architecture Code Level Diagrams

##### 4.2.6.6.1. Bounded Context Domain Layer Class Diagrams


Aquí se detalla la arquitectura del software a nivel de código, presentando la clase room dentro del contexto de dominio. El diagrama muestra los atributos de la clase y métodos asociados.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//dcode-room.png" alt="UPC">
</p>

##### 4.2.6.6.2. Bounded Context Database Design Diagram

Este diagrama representa el diseño de la base de datos dentro de un Bounded Context específico del sistema. En él se detallan las entidades principales, sus atributos clave y las relaciones entre ellas, según las responsabilidades y límites funcionales de cada contexto. Su objetivo es proporcionar una visión clara y aislada de cómo se estructuran y gestionan los datos dentro de ese contexto, asegurando una alta cohesión interna y una baja dependencia con otros contextos del dominio.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bd-rooms.png" alt="UPC">
</p>

### 4.2.7. Bounded Context: Player List

#### 4.2.7.1. Domain Layer

##### 4.2.7.1.1. Model

###### 4.2.7.1.1.1. Aggregates

- PlayerList: es una entidad JPA que representa una relación entre los usuarios, las salas y los chatrooms dentro del sistema. Esta clase forma parte del dominio de la lista de jugadores (PlayerList), y se asocia a las entidades Rooms, User, y ChatRoom.

#### 4.2.7.2. Interface Layer

##### 4.2.7.2.1. Resources

- PlayerListDTO: es un Data Transfer Object (DTO) que se utiliza para transferir información sobre un jugador, la sala (roomId), el chat asociado (chatRoomId), y el usuario (userId). Utiliza la anotación @JsonView para controlar qué atributos se exponen según el contexto, permitiendo una serialización más flexible de los datos.

##### 4.2.7.2.2. Transform

- PlayerListResourceFromEntityAssembler: es responsable de convertir una entidad PlayerList en un DTO (Data Transfer Object) PlayerListDTO. El método toResourceFromEntity toma un objeto PlayerList y mapea sus propiedades a un nuevo objeto PlayerListDTO. Esto facilita la transferencia de datos entre las capas de la aplicación, permitiendo que la capa de presentación reciba datos estructurados y sin lógica de negocio.

##### 4.2.7.2.3. Controllers

- PlayerListController : es un controlador de Spring que gestiona las solicitudes HTTP relacionadas con las listas de jugadores en una sala de juego. Aquí te explico brevemente sus partes principales:

  - Endpoints:

      - POST api/v1/player-lists/join

        - Permite a un usuario unirse a una sala de juego y al chat asociado. El usuario debe estar autenticado. Si el usuario ya está en la sala o no tiene suficientes créditos, se produce un error. Si ocurre cualquier otro problema, los jugadores en la sala reciben un reembolso.

        - Parámetros:

          - roomId (requerido): El ID de la sala a la que el jugador desea unirse.

        - Respuesta exitosa:

          - Código de estado: 200 OK

        - Respuestas de error:

          - Código de estado: 401 Unauthorized si el usuario no está autenticado.

          - Código de estado: 400 Bad Request si ocurre un error relacionado con el estado del jugador o la sala.

          - Código de estado: 500 Internal Server Error si la consulta a la base de datos no devuelve un resultado único.

      - GET api/v1/player-lists/room/{roomId}

        - Obtiene la lista de jugadores que están en una sala específica.

        - Parámetros:

          - roomId (requerido): El ID de la sala.

        - Respuesta exitosa:

          - Código de estado: 200 OK

#### 4.2.7.3. Infrastructure Layer

- PlayerListRepository: Es una interfaz de repositorio de Spring Data JPA para gestionar las entidades PlayerList relacionadas con las salas y los usuarios en el sistema. Esta interfaz permite realizar operaciones CRUD en la base de datos de PlayerList, así como consultas personalizadas para obtener información de los jugadores en salas específicas.

  - Metodos:

    - deleteByRoomId(Long roomId)

      - Elimina todos los registros de PlayerList asociados a una sala especificada por roomId.

      - Anotaciones:

        - @Transactional: Garantiza que la operación se realice dentro de una transacción.

        - @Modifying: Indica que se trata de una operación de modificación (en este caso, una eliminación).

      - Parámetros:

        - roomId: El ID de la sala.

    - existsByRoomAndUser(Rooms room, User user)

      - Verifica si un jugador (usuario) ya está en una sala específica.

      - Parámetros:

        - room: La sala en cuestión.

        - user: El jugador que se desea verificar.

    - findByRoomId(Long roomId)

      - Obtiene la lista de jugadores (PlayerList) asociados a una sala específica.

      - Parámetros:

        - roomId: El ID de la sala.

        - Devuelve: Una lista de objetos PlayerList correspondientes a los jugadores en esa sala.

#### 4.2.7.4. Bounded Context Software Architecture Component Level Diagrams

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//playerlist-component.png" alt="UPC">
</p>

#### 4.2.7.5. Bounded Context Software Architecture Code Level Diagrams

##### 4.2.7.5.1. Bounded Context Domain Layer Class Diagrams

Aquí se detalla la arquitectura del software a nivel de código, presentando la clase playerlist dentro del contexto de dominio. El diagrama muestra los atributos de la clase y métodos asociados.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//dcode-pl.png" alt="UPC">
</p>

##### 4.2.7.5.2. Bounded Context Database Design Diagram

Este diagrama representa el diseño de la base de datos dentro de un Bounded Context específico del sistema. En él se detallan las entidades principales, sus atributos clave y las relaciones entre ellas, según las responsabilidades y límites funcionales de cada contexto. Su objetivo es proporcionar una visión clara y aislada de cómo se estructuran y gestionan los datos dentro de ese contexto, asegurando una alta cohesión interna y una baja dependencia con otros contextos del dominio.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bd-pl.png" alt="UPC">
</p>


### 4.2.8. Bounded Context: Chat Room

#### 4.2.8.1. Domain Layer

##### 4.2.8.1.1. Model

###### 4.2.8.1.1.1. Aggregates

- ChatRoom: Representa una sala de chat vinculada a una sala física (deporte o reunión). Permite gestionar los jugadores (usuarios) en la sala de chat y los mensajes que se envían en esa sala.

###### 4.2.8.1.1.2. Entities

- Message: representa un mensaje enviado en una sala de chat.

- MessageContentDTO: es un objeto de transferencia de datos (DTO) que solo contiene el contenido del mensaje.

- MessageDTO: es un DTO que representa un mensaje con más información que el MessageContentDTO.

##### 4.2.8.1.2. Services

- ChatRoomCommandService: define los métodos relacionados con la gestión de salas de chat y mensajes dentro de esas salas.

  Contiene los siguientes métodos:

  - createChatRoom(Rooms room): Crea una nueva sala de chat asociada a una sala (Rooms).

  - sendMessage(Long chatRoomId, String content, Long userId): Envía un mensaje a una sala de chat específica.

  - getMessages(Long chatRoomId): Recupera todos los mensajes de una sala de chat específica.

##### 4.2.8.1.3. Config

- ChatWebSocketHandler:

  - Metodos:

    - afterConnectionEstablished(WebSocketSession session): Añade una nueva sesión de WebSocket a la lista de sesiones activas cuando se establece la conexión.

    - handleTextMessage(WebSocketSession session, TextMessage message): Recibe mensajes de texto, extrae el roomId y userId, y verifica si el usuario pertenece a la sala. Si no es así, cierra la sesión.

    - extractRoomId(JsonNode jsonNode): Extrae el roomId del mensaje recibido en formato JSON.

    - extractUserId(JsonNode jsonNode): Extrae el userId del mensaje recibido en formato JSON.

    - isUserInRoom(String userId, String roomId): Verifica si un usuario está en una sala específica al consultar la lista de jugadores de la sala.

    - afterConnectionClosed(WebSocketSession session, CloseStatus status): Elimina la sesión WebSocket de la lista de sesiones activas cuando la conexión se cierra.

    - broadcastMessage(TextMessage message): Envía un mensaje de texto a todas las sesiones activas de WebSocket.

- WebSocketConfig

  - Metodos:
    
    - registerWebSocketHandlers(WebSocketHandlerRegistry registry): Registra el ChatWebSocketHandler para manejar conexiones WebSocket en la ruta /ws/chat.

    - chatWebSocketHandler(): Define el bean ChatWebSocketHandler para ser usado en la configuración de WebSocket.

#### 4.2.8.2. Interface Layer

##### 4.2.8.2.1. Controllers

- ChatRoomController: maneja las operaciones relacionadas con las salas de chat, como crear salas de chat, enviar mensajes y obtener los mensajes de una sala.

  - Métodos:

    - POST /api/v1/chat/rooms

      - Crea una nueva sala de chat.

      - Función: Recibe un objeto Rooms en el cuerpo de la solicitud y devuelve la sala de chat creada.

    - POST /api/v1/chat/rooms/{chatRoomId}/messages

      - Envía un mensaje a una sala de chat.

      - Función: Recibe el contenido del mensaje en el cuerpo, valida que el usuario esté autenticado y sea parte de la sala, y luego transmite el mensaje a través de WebSocket a todos los usuarios de la sala.

    - GET /api/v1/chat/rooms/{chatRoomId}/messages

      - Obtiene los mensajes de una sala de chat.

      - Función: Devuelve una lista de mensajes existentes en la sala de chat especificada.

#### 4.2.8.3. Application Layer 

#### 4.2.8.3.1. Command Services

- ChatRoomCommandServiceImpl implementa la lógica de negocio para las operaciones relacionadas con las salas de chat. Estas operaciones incluyen la creación de salas de chat, el envío de mensajes y la obtención de mensajes.

  - Metodos:

    - createChatRoom(Rooms room)

      - Crea una nueva sala de chat a partir de la sala de reservas (Rooms).

      - Función: Crea un objeto ChatRoom, asigna un nombre basado en la reserva y agrega a los jugadores (incluyendo al creador de la sala).

    - isUserInRoom(Long chatRoomId, Long userId)

      - Verifica si un usuario está en una sala de chat.

      - Función: Busca la sala de chat por ID y verifica si el usuario con el ID proporcionado está en la lista de jugadores de esa sala.

    - sendMessage(Long chatRoomId, String content, Long userId)

      - Envía un mensaje a una sala de chat.

      - Función: Crea un nuevo mensaje, lo asocia a la sala de chat y al usuario, y luego guarda el mensaje en la base de datos.

    - getMessages(Long chatRoomId)

      - Obtiene todos los mensajes de una sala de chat.

      - Función: Recupera los mensajes de la sala de chat especificada.

#### 4.2.8.4. Infrastructure Layer 

- ChatRoomRepository: Esta interfaz extiende JpaRepository y proporciona métodos para acceder a las salas de chat (ChatRoom).

  - Metodos:

    - findByRoomId(Long roomId): Busca una sala de chat usando el ID de la sala (de la entidad Rooms). Devuelve un Optional<ChatRoom>.

    - deleteByRoomId(Long roomId): Elimina una sala de chat basada en el ID de la sala de la entidad Rooms.

- MessageRepository: Esta interfaz extiende JpaRepository y proporciona métodos para acceder a los mensajes de las salas de chat (Message).

  - Metodos:

    - findByChatRoom(ChatRoom chatRoom): Obtiene todos los mensajes asociados a una sala de chat específica (ChatRoom). Devuelve una lista de mensajes.

#### 4.2.8.5. Bounded Context Software Architecture Component Level Diagrams 


<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//chat-component.png" alt="UPC">
</p>

#### 4.2.8.6. Bounded Context Software Architecture Code Level Diagrams

##### 4.2.8.6.1. Bounded Context Domain Layer Class Diagrams

Aquí se detalla la arquitectura del software a nivel de código, presentando la clase chatroom dentro del contexto de dominio. El diagrama muestra los atributos de la clase y métodos asociados.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//dcode-chatroom.png" alt="UPC">
</p>

##### 4.2.8.6.2. Bounded Context Database Design Diagram

Este diagrama representa el diseño de la base de datos dentro de un Bounded Context específico del sistema. En él se detallan las entidades principales, sus atributos clave y las relaciones entre ellas, según las responsabilidades y límites funcionales de cada contexto. Su objetivo es proporcionar una visión clara y aislada de cómo se estructuran y gestionan los datos dentro de ese contexto, asegurando una alta cohesión interna y una baja dependencia con otros contextos del dominio.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bd-chat.png" alt="UPC">
</p>

### 4.2.9. Bounded Context: Deposit

#### 4.2.9.1. Domain Layer

##### 4.2.9.1.1. Model

###### 4.2.9.1.1.1. Aggregates

- Deposit: representa un depósito realizado por un usuario en el sistema. Está mapeada a la tabla deposits en la base de datos y hereda de AuditableAbstractAggregateRoot para manejar auditoría (creación, modificación, etc.).

###### 4.2.9.1.1.2. Commands

- CreateDepositCommand: es un record en Java, que es una clase inmutable diseñada para almacenar datos. En este caso, se utiliza para representar un comando para crear un depósito.

###### 4.2.9.1.1.3. Queries

- GetDepositByIdQuery: es un record en Java que representa una consulta para obtener un depósito por su ID.

##### 4.2.9.1.2. Services

- DepositCommandService: Esta interfaz define los métodos relacionados con las acciones que modifican el estado del sistema, como crear un depósito o guardar un depósito.

  - Metodos:

    - Optional<Deposit> handle(CreateDepositCommand command): Este método recibe un comando (CreateDepositCommand) para manejar la creación de un depósito. Retorna un Optional<Deposit>, lo que significa que podría no encontrar un depósito si algo falla.

    - void save(Deposit deposit): Este método guarda un depósito en el sistema. No retorna nada, solo realiza la acción de persistencia.

- DepositQueryService: Esta interfaz maneja las consultas que no modifican el estado del sistema, como obtener información sobre un depósito.

  - Métodos:
    
    - Optional<Deposit> handle(GetDepositByIdQuery query): Este método recibe una consulta (GetDepositByIdQuery) para obtener un depósito específico por su id. Retorna un Optional<Deposit> para indicar si el depósito fue encontrado o no.

#### 4.2.9.2. Interface Layer

##### 4.2.9.2.1. Controllers

- DepositController: es responsable de manejar las solicitudes relacionadas con la creación y gestión de depósitos en el sistema. La clase interactúa con varias dependencias como PayPal, el servicio de tokens, y los repositorios de usuarios y pagos. Proporciona endpoints para crear depósitos y procesar pagos mediante PayPal.

  - Endpoints:

    - POST /api/v1/deposit/create-deposit

      - Crea un depósito utilizando PayPal y devuelve la URL de aprobación de PayPal.

      - Entrada: Monto del depósito (como parámetro amount).

      - Salida: URL de aprobación de PayPal si el pago se crea con éxito, mensaje de error en caso contrario.

    - POST /api/v1/deposit/payment-deposits/success

      - Procesa el pago aprobado por PayPal, guarda el depósito y actualiza el saldo del usuario.

      - Entrada: paymentId, PayerID, y jwtToken (como parámetros de consulta).

      - Salida: Redirección a la página de éxito si el pago es aprobado, mensaje de error en caso de fallo.

#### 4.2.9.3. Application Layer 

##### 4.2.9.3.1. Command Services

- DepositCommandServiceImpl: maneja la lógica de negocio relacionada con la creación y almacenamiento de depósitos. Utiliza los repositorios DepositRepository y UserRepository para interactuar con la base de datos.

  - Metodos:
    
      - Optional<Deposit> handle(CreateDepositCommand command):

        - Recibe un comando de creación de depósito (CreateDepositCommand), que contiene un userId y una cantidad (amount).

        - Busca al usuario en la base de datos usando userRepository y lanza una excepción si el usuario no se encuentra.

        - Crea un nuevo objeto Deposit usando el user y amount obtenidos.

        - Guarda el nuevo depósito en la base de datos a través del depositRepository.

        - Retorna el depósito creado envuelto en un Optional (si todo es exitoso).

      - void save(Deposit deposit):

        - Recibe un objeto Deposit y lo guarda en la base de datos utilizando el depositRepository.

        - No retorna nada, simplemente persiste el objeto.

##### 4.2.9.3.2. Query Services

- DepositQueryServiceImpl: se encarga de manejar la consulta de depósitos. Utiliza el DepositRepository para interactuar con la base de datos y recuperar la información de los depósitos.

  - Metodos:

    - Optional<Deposit> handle(GetDepositByIdQuery query):

      - Recibe una consulta de tipo GetDepositByIdQuery, que contiene un id de depósito.

      - Utiliza el DepositRepository para buscar un depósito en la base de datos con el id proporcionado en la consulta.

      - Retorna el depósito encontrado como un Optional<Deposit>, lo que permite manejar la posibilidad de que no se encuentre el depósito.

#### 4.2.9.4. Infrastructure Layer 

- DepositRepository: proporciona la funcionalidad básica de CRUD para la entidad Deposit sin necesidad de implementar métodos adicionales. Aquí se define una interfaz sencilla para acceder a los datos de la tabla deposits en la base de datos.

  - Metodos: 
  
    - save(Deposit deposit): Guarda un depósito en la base de datos.

    - findById(Long id): Busca un depósito por su ID.

    - findAll(): Obtiene todos los depósitos.

    - deleteById(Long id): Elimina un depósito por su ID.

#### 4.2.9.5. Bounded Context Software Architecture Component Level Diagrams 

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//deposit-component.png" alt="UPC">
</p>

#### 4.2.9.6. Bounded Context Software Architecture Code Level Diagrams

##### 4.2.9.6.1. Bounded Context Domain Layer Class Diagrams

Aquí se detalla la arquitectura del software a nivel de código, presentando la clase deposit dentro del contexto de dominio. El diagrama muestra los atributos de la clase y métodos asociados.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//dcode-deposit.png" alt="UPC">
</p>

##### 4.2.9.6.2. Bounded Context Database Design Diagram

Este diagrama representa el diseño de la base de datos dentro de un Bounded Context específico del sistema. En él se detallan las entidades principales, sus atributos clave y las relaciones entre ellas, según las responsabilidades y límites funcionales de cada contexto. Su objetivo es proporcionar una visión clara y aislada de cómo se estructuran y gestionan los datos dentro de ese contexto, asegurando una alta cohesión interna y una baja dependencia con otros contextos del dominio.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bd-deposit.png" alt="UPC">
</p>

### 4.2.10. Bounded Context: Bank Transfer

#### 4.2.10.1. Domain Layer

##### 4.2.10.1.1. Model

###### 4.2.10.1.1.1. Aggregates

- BankTransfer: representa una solicitud de transferencia bancaria realizada por un usuario propietario. Está mapeada a una tabla de base de datos mediante JPA.

###### 4.2.10.1.1.2. Commands

- CreateBankTransferCommand: es un record en Java, utilizado para definir un objeto inmutable que contiene los datos necesarios para crear una transferencia bancaria. Este record se valida en su constructor para asegurarse de que todos los campos requeridos estén presentes y no sean vacíos o nulos.

###### 4.2.10.1.1.3. Queries

- GetBankTransferByUserIdQuery: es un record en Java que encapsula la consulta para obtener las transferencias bancarias asociadas a un usuario específico, identificado por su userId.

##### 4.2.10.1.2. Services

- BankTransferCommandServices: define un servicio relacionado con la creación de transferencias bancarias. Específicamente, el método handle maneja la lógica para crear una transferencia bancaria a partir de un CreateBankTransferCommand.

  - Metodos:

    - handle(Long id, CreateBankTransferCommand command):

#### 4.2.10.2. Interface Layer 

##### 4.2.10.2.1. Resources

- CreateBankTransferResource: Este recurso es utilizado para recibir los datos necesarios para crear una nueva transferencia bancaria.

- BankTransferResource: Este recurso se utiliza para representar una transferencia bancaria que ya ha sido creada o está en proceso, y se envía como respuesta en la API.

##### 4.2.10.2.2. Transform

- CreateBankTransferCommandFromResourceAssembler: Este ensamblador convierte el recurso de entrada (CreateBankTransferResource) en un comando (CreateBankTransferCommand) que se puede usar en la lógica de negocio, generalmente en el servicio de comandos.

  - Metodo:
      
    - toCommandFromResource:

      - Toma un objeto CreateBankTransferResource como entrada.

        - Extrae los valores de las propiedades del recurso y los pasa al constructor de CreateBankTransferCommand.

        - Devuelve un objeto de tipo CreateBankTransferCommand.

- BankTransferResourceFromEntityAssembler: Este ensamblador convierte una entidad de dominio (BankTransfer) en un recurso (BankTransferResource) que será devuelto al cliente en la respuesta de la API.

  - Metodo:

    - toResourceFromEntity:

      - Toma una entidad BankTransfer como entrada.

      - Extrae las propiedades necesarias de la entidad y las usa para crear un nuevo BankTransferResource.

      - Devuelve el objeto BankTransferResource, que contiene los detalles de la transferencia bancaria.

##### 4.2.10.2.3. Controllers

- BankTransferController: es un controlador en Spring Boot que maneja las solicitudes HTTP relacionadas con las transferencias bancarias. 

  - Endpoints:
  
    - POST /api/v1/bank-transfer/create:

      - Función: Permite a los usuarios con rol OWNER crear una transferencia bancaria.

      - Validaciones:

        - Solo los lunes entre las 00:00 y las 06:00.

        - Tipo de transferencia debe ser CC o CCI.

        - Solo si no existe una transferencia pendiente.

      - Acción: Crea una transferencia y asigna el monto correspondiente de los créditos del usuario.

    - GET /api/v1/bank-transfer/all:

      - Función: Permite a los administradores ver todas las transferencias bancarias.

      - Validaciones: Solo los usuarios con rol ADMIN pueden ver todas las transferencias.

      - Acción: Devuelve todas las transferencias en el sistema.

    - GET /api/v1/bank-transfer/user/{userId}:

      - Función: Permite a un administrador o al mismo usuario ver sus propias transferencias bancarias.

      - Validaciones:

        - El administrador puede ver todas las transferencias.

        - Los usuarios solo pueden ver sus propias transferencias.

      - Acción: Devuelve las transferencias de un usuario específico.

    - PATCH /api/v1/bank-transfer/update-transfer/{id}:

      - Función: Permite a los administradores actualizar el estado de una transferencia bancaria a CONFIRMED.

      - Validaciones:

        - Solo los usuarios con rol ADMIN pueden actualizar el estado.

        - Solo se puede actualizar si el estado actual es PENDING.

      - Acción: Confirma la transferencia y actualiza los créditos del usuario y del administrador

#### 4.2.10.3. Application Layer 

##### 4.2.10.3.1. Command Services

-  BankTransferCommandServicesImpl: es una implementación del servicio que maneja las operaciones relacionadas con las transferencias bancarias.

  - Metodos:

    - handle():

      - Función: Procesa la solicitud para crear una nueva transferencia bancaria.

      - Acción:

        - Busca el usuario correspondiente a través de su id usando el repositorio de usuarios.

        - Crea un objeto BankTransfer utilizando el comando CreateBankTransferCommand y el usuario encontrado.

        - Retorna una Optional<BankTransfer> con la transferencia bancaria creada.

#### 4.2.10.4. Infrastructure Layer 

- BankTransferRepository: es un repositorio que maneja las operaciones de acceso a la base de datos para la entidad BankTransfer.

  - Metodos:

    - findByUserId(Long userId):

      - Función: Obtiene una lista de transferencias bancarias asociadas a un usuario específico.

      - Retorna: Una lista de objetos BankTransfer para el userId proporcionado.

    - findByUserIdAndStatus(Long userId, Status status):

      - Función: Obtiene una transferencia bancaria asociada a un usuario y con un estado específico.

      - Retorna: Un Optional<BankTransfer> si se encuentra la transferencia con el userId y el status indicados.

#### 4.2.10.5. Bounded Context Software Architecture Component Level Diagrams 

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//banktransfer-component.png" alt="UPC">
</p>

#### 4.2.10.6. Bounded Context Software Architecture Code Level Diagrams

##### 4.2.10.6.1. Bounded Context Domain Layer Class Diagrams

Aquí se detalla la arquitectura del software a nivel de código, presentando la clase User dentro del contexto de dominio. El diagrama muestra los atributos de la clase y métodos asociados.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//code-banktransfer.png" alt="UPC">
</p>

##### 4.2.10.6.2. Bounded Context Database Design Diagram

Este diagrama representa el diseño de la base de datos dentro de un Bounded Context específico del sistema. En él se detallan las entidades principales, sus atributos clave y las relaciones entre ellas, según las responsabilidades y límites funcionales de cada contexto. Su objetivo es proporcionar una visión clara y aislada de cómo se estructuran y gestionan los datos dentro de ese contexto, asegurando una alta cohesión interna y una baja dependencia con otros contextos del dominio.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bd-bank.png" alt="UPC">
</p>

### 4.2.11. Bounded Context: Payments

#### 4.2.11.1. Domain Layer

##### 4.2.11.1.1. Model

###### 4.2.11.1.1.1. Aggregates

- Payments: es una entidad JPA que representa los pagos realizados por los usuarios. Extiende de AuditableAbstractAggregateRoot, lo que implica que tiene un registro de auditoría, como por ejemplo fechas de creación y modificación.

###### 4.2.11.1.1.2. Queries

- GetPaymentsByIdQuery: es un record que representa una consulta para obtener un pago por su identificador (id). Un record es una forma inmutable de representar datos en Java, similar a una clase con solo atributos y sin necesidad de escribir los métodos getter, equals(), hashCode(), etc.

##### 4.2.11.1.2. Services

- PaymentsQueryService: define un servicio para consultar los pagos almacenados. Su propósito es manejar consultas relacionadas con los pagos, particularmente para obtener un pago específico a partir de un identificador (id).

  - Métodos:
    - handle(GetPaymentsByIdQuery query):

      - Parámetro: GetPaymentsByIdQuery query - Es un objeto que contiene el id del pago que se desea consultar.

      - Retorno: Optional<Payments> - Devuelve un Optional que contiene el objeto Payments si se encuentra el pago con el id proporcionado, o está vacío si no existe.

#### 4.2.11.2. Application Layer 

##### 4.2.11.2.1. Command Services

- PayPalPaymentServiceImpl: Esta clase maneja las interacciones con la API de PayPal para crear, ejecutar y reembolsar pagos.

  - Métodos:

    - createPayment: Crea un pago en PayPal utilizando los detalles de la transacción (monto, moneda, método de pago, etc.). Configura los detalles del pago como descripción, URL de éxito y cancelación, y devuelve el objeto Payment de PayPal.

    - executePayment: Ejecuta un pago previamente creado en PayPal usando el paymentId y el payerId del usuario. Este método realiza el pago en PayPal después de que el usuario autorice la transacción.

    - refundPayment: Realiza un reembolso de un pago específico usando su paymentId. El método obtiene la transacción y la relacionada con el pago, luego intenta reembolsar el pago a través de la API de PayPal.

- PaypalConfig: Esta clase es responsable de configurar y crear una instancia de APIContext que es necesaria para interactuar con la API de PayPal.

  - Métodos:

    - apiContext: Configura el contexto de la API de PayPal utilizando las credenciales almacenadas en un archivo .env (por ejemplo, PAYPAL_CLIENT_ID, PAYPAL_CLIENT_SECRET, PAYPAL_MODE). Esto permite interactuar con la API de PayPal.

##### 4.2.11.2.2. Query Services

- PaymentsQueryServiceImpl: Esta clase es una implementación del servicio de consulta relacionado con los pagos. Su objetivo es manejar las solicitudes de consultas de pagos por ID.

  - Método:

    - handle(GetPaymentsByIdQuery query):

      - Este método recibe un objeto GetPaymentsByIdQuery, que contiene el id del pago que se desea consultar.

      - Luego, utiliza el PaymentsRepository para buscar un pago con el ID proporcionado en la base de datos.

      - Retorna un Optional<Payments>, lo que indica que puede o no existir un pago con ese ID.

#### 4.2.11.3. Infrastructure Layer 

- PaymentsRepository: Esta interfaz extiende de JpaRepository, lo que le permite acceder a las operaciones CRUD básicas (Crear, Leer, Actualizar, Eliminar) para la entidad Payments. Además, define un método personalizado para realizar consultas específicas.

  - Métodos:

    - findByTransactionId(String transactionId):

      - Este método permite buscar un pago específico por su transactionId.

      - Devuelve un Optional<Payments>, lo que indica que el pago puede o no existir en la base de datos con ese transactionId.

#### 4.2.11.4. Bounded Context Software Architecture Component Level Diagrams 

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//payment-component.png" alt="UPC">
</p>

#### 4.2.11.5. Bounded Context Software Architecture Code Level Diagrams

##### 4.2.11.5.1. Bounded Context Domain Layer Class Diagrams

Aquí se detalla la arquitectura del software a nivel de código, presentando la clase payments dentro del contexto de dominio. El diagrama muestra los atributos de la clase y métodos asociados.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//dcode-payment.png" alt="UPC">
</p>


##### 4.2.11.5.2. Bounded Context Database Design Diagram

Este diagrama representa el diseño de la base de datos dentro de un Bounded Context específico del sistema. En él se detallan las entidades principales, sus atributos clave y las relaciones entre ellas, según las responsabilidades y límites funcionales de cada contexto. Su objetivo es proporcionar una visión clara y aislada de cómo se estructuran y gestionan los datos dentro de ese contexto, asegurando una alta cohesión interna y una baja dependencia con otros contextos del dominio.

<p align="center">
  <img src="https://raw.githubusercontent.com//Tecny//development-of-iot-solutions-final-project//develop//images//bd-payments.png" alt="UPC">
</p>

# Conclusiones

En la dinámica urbana de Lima Metropolitana, los aficionados al fútbol y al billar se enfrentan a una problemática común: la dificultad para encontrar y reservar canchas y mesas de forma rápida y segura. Esta situación no solo frustra a los jugadores, sino que también limita las oportunidades para disfrutar de estos deportes tan populares en la ciudad.

En las siguientes secciones, exploraremos en detalle las conclusiones extraídas del análisis del perfil de D´taquito, destacando su relevancia en el mercado actual, su enfoque centrado en el usuario y las oportunidades futuras para su crecimiento y desarrollo.

- D'Taquito surgió al identificar una necesidad importante en el mercado de Lima Metropolitana: la dificultad para encontrar y reservar canchas de fútbol y mesas de billar de manera rápida, conveniente y segura. Observamos que muchos aficionados al fútbol y al billar enfrentaban obstáculos al intentar organizar partidos o simplemente disfrutar de una partida con amigos. La falta de una solución integral para este problema nos llevó a reconocer una oportunidad significativa para D'Taquito de satisfacer esta necesidad no abordada en el mercado.
- La popularidad arraigada del fútbol y el creciente interés en el billar en Lima Metropolitana indican un mercado potencialmente vasto para D'Taquito. Nuestros estudios de mercado revelaron que una gran cantidad de personas, aproximadamente el 71.8% según nuestras encuestas, juegan fútbol al menos una vez a la semana. Además, un porcentaje significativo de estos jugadores expresó interés en la reserva de canchas sintéticas, lo que subraya aún más la demanda latente en el mercado. El hecho de que el 89.6% de los encuestados estén dispuestos a utilizar una plataforma digital para agilizar las reservas confirma la necesidad y el potencial de una solución como D'Taquito en el mercado.
- D'Taquito se distingue en el mercado por ofrecer una experiencia de usuario superior y una solución integral para la reserva de instalaciones deportivas. Nuestra plataforma web ofrece una interfaz intuitiva y fácil de usar, permitiendo a los usuarios encontrar y reservar instalaciones desde cualquier dispositivo con acceso a Internet. La amplitud de opciones disponibles, combinada con información detallada sobre cada instalación, como fotos e instalaciones disponibles, resalta la propuesta de valor de D'Taquito. Además, la integración de opciones de pago seguro garantiza transacciones confiables y sin complicaciones para nuestros usuarios.
- La plataforma de D'Taquito se centra en mejorar significativamente la experiencia del usuario al proporcionar una amplia gama de opciones de canchas y salones disponibles en diferentes ubicaciones. Nuestro objetivo es facilitar a los usuarios la búsqueda y reserva de instalaciones deportivas de manera rápida y sencilla. Además, la información detallada sobre cada instalación, combinada con opciones de pago seguro integradas, garantiza que los usuarios puedan tomar decisiones informadas y realizar transacciones de forma confiable a través de nuestra plataforma.Reconocemos que el éxito a largo plazo de D'Taquito depende de nuestra capacidad para adaptarnos y mejorar constantemente para satisfacer las necesidades cambiantes de nuestros usuarios. Planeamos expandirnos más allá de Lima Metropolitana y explorar oportunidades en otras ciudades y países. Además, estamos comprometidos con la mejora continua de nuestra plataforma, mediante la integración de nuevas características, la optimización para dispositivos móviles y la implementación de retroalimentación de los usuarios para garantizar que D'Taquito siga siendo líder en el mercado de reserva de instalaciones deportivas.
- El backend de D'Taquito se ha creado para hacer que reservar espacios deportivos sea rápido y seguro. Nos hemos centrado en garantizar la protección de los datos de los usuarios y en ofrecer una experiencia fluida, incluso en momentos de mucha demanda. Con sistemas de alertas y validación de datos, buscamos mejorar aún más la confiabilidad de la plataforma. Además, estamos comprometidos a seguir mejorando y adaptando nuestro backend para satisfacer las necesidades de los usuarios y mantenernos a la vanguardia. Como equipo, nos esforzamos por ofrecer la mejor experiencia posible mientras D'Taquito sigue creciendo.

# Bibliografia

Atlassian. (s/f). *Configuration management*. Atlassian. Recuperado el 14 de abril de 2024, de https://www.atlassian.com/microservices/microservices-architecture/configuration-management

Creasoft. (s/f). *Inicio*. Micancha.pe. Recuperado el 14 de abril de 2024, de https://www.micancha.pe/

Donde juego. (s/f). *Dondejuegoapp.com*. Recuperado el 14 de abril de 2024, de https://www.dondejuegoapp.com/

Muro, L. (2020, marzo). *Plataforma digital para la reserva de canchas sinteticas*. Repositorio Universidad de Lima. https://repositorio.ulima.edu.pe/bitstream/handle/20.500.12724/12082/Muro_Plataforma-digital-reserva-canchas.pdf?sequence=1&isAllowed=y

*Reserva tu cancha al instante*. (s/f). ATC. Recuperado el 14 de abril de 2024, de https://alquilatucancha.com/

Scholten, K. (2023, agosto 16). *Understanding agile: The Difference Between a Product Backlog and a User Story*. CardBoard. https://cardboardit.com/2023/08/understanding-agile-the-difference-between-a-product-backlog-and-a-user-story/

*The C4 model for visualising software architecture*. (s/f). C4model.com. Recuperado el 14 de abril de 2024, de https://c4model.com/

*The complete guide to Lean UX*. (2022, diciembre 13). Webflow. https://webflow.com/blog/lean-ux

Vaidya, M. (2020, septiembre 5). *Accessibility: Guidelines for information architecture, UX design, and visual design*. IBM Design. https://medium.com/design-ibm/accessibility-guidelines-for-information-architecture-ux-design-and-visual-design-5ae33ed1d52d

Zmijewski, B. (2024, enero 4). *Needfinding: Crafting products aligned with user needs*. Helio. https://helio.app/blog/the-needfinding-playbook-crafting-products-aligned-with-genuine-desires/

# Anexos

Enlace a los videos requeridos en carpeta distribuidas:


As-is y to-be mapping Miro:
https://miro.com/app/board/uXjVKUmcOCw=/?share_link_id=98435150377

Enlace a figma:
https://www.figma.com/file/9b5VMPb1CCHGYuWQkP2554/UX-Design?type=design&node-id=0%3A1&mode=design&t=K3kzNMJ1UGVbxDsc-1

Enlace al repositorio en Github:
